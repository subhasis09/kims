/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-pages-internals"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Capp-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cnot-found-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Capp-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cnot-found-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/app-router.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-page.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/error-boundary.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/not-found-boundary.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDS0lJVCU1QyU1Q0Rlc2t0b3AlNUMlNUN3ZWJkZXYlNUMlNUNraWlpaW0lNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZGlzdCU1QyU1Q2NsaWVudCU1QyU1Q2NvbXBvbmVudHMlNUMlNUNhcHAtcm91dGVyLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkMlM0ElNUMlNUNVc2VycyU1QyU1Q0tJSVQlNUMlNUNEZXNrdG9wJTVDJTVDd2ViZGV2JTVDJTVDa2lpaWltJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNjbGllbnQlNUMlNUNjb21wb25lbnRzJTVDJTVDY2xpZW50LXBhZ2UuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDS0lJVCU1QyU1Q0Rlc2t0b3AlNUMlNUN3ZWJkZXYlNUMlNUNraWlpaW0lNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZGlzdCU1QyU1Q2NsaWVudCU1QyU1Q2NvbXBvbmVudHMlNUMlNUNlcnJvci1ib3VuZGFyeS5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJDJTNBJTVDJTVDVXNlcnMlNUMlNUNLSUlUJTVDJTVDRGVza3RvcCU1QyU1Q3dlYmRldiU1QyU1Q2tpaWlpbSU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1Q25leHQlNUMlNUNkaXN0JTVDJTVDY2xpZW50JTVDJTVDY29tcG9uZW50cyU1QyU1Q2xheW91dC1yb3V0ZXIuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDS0lJVCU1QyU1Q0Rlc2t0b3AlNUMlNUN3ZWJkZXYlNUMlNUNraWlpaW0lNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZGlzdCU1QyU1Q2NsaWVudCU1QyU1Q2NvbXBvbmVudHMlNUMlNUNub3QtZm91bmQtYm91bmRhcnkuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDS0lJVCU1QyU1Q0Rlc2t0b3AlNUMlNUN3ZWJkZXYlNUMlNUNraWlpaW0lNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZGlzdCU1QyU1Q2NsaWVudCU1QyU1Q2NvbXBvbmVudHMlNUMlNUNyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsZ1BBQTBJO0FBQzFJO0FBQ0Esa1BBQTJJO0FBQzNJO0FBQ0Esd1BBQThJO0FBQzlJO0FBQ0Esc1BBQTZJO0FBQzdJO0FBQ0EsZ1FBQWtKO0FBQ2xKO0FBQ0Esb1JBQTRKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/M2I3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXEtJSVRcXFxcRGVza3RvcFxcXFx3ZWJkZXZcXFxca2lpaWltXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcYXBwLXJvdXRlci5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcS0lJVFxcXFxEZXNrdG9wXFxcXHdlYmRldlxcXFxraWlpaW1cXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxjbGllbnQtcGFnZS5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcS0lJVFxcXFxEZXNrdG9wXFxcXHdlYmRldlxcXFxraWlpaW1cXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxlcnJvci1ib3VuZGFyeS5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcS0lJVFxcXFxEZXNrdG9wXFxcXHdlYmRldlxcXFxraWlpaW1cXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxsYXlvdXQtcm91dGVyLmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxLSUlUXFxcXERlc2t0b3BcXFxcd2ViZGV2XFxcXGtpaWlpbVxcXFxub2RlX21vZHVsZXNcXFxcbmV4dFxcXFxkaXN0XFxcXGNsaWVudFxcXFxjb21wb25lbnRzXFxcXG5vdC1mb3VuZC1ib3VuZGFyeS5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcS0lJVFxcXFxEZXNrdG9wXFxcXHdlYmRldlxcXFxraWlpaW1cXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Capp-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cnot-found-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/lib/url.js":
/*!*******************************************!*\
  !*** ./node_modules/next/dist/lib/url.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getPathname: function getPathname() {\n    return _getPathname;\n  },\n  isFullStringUrl: function isFullStringUrl() {\n    return _isFullStringUrl;\n  },\n  parseUrl: function parseUrl() {\n    return _parseUrl;\n  }\n});\nvar DUMMY_ORIGIN = \"http://n\";\nfunction getUrlWithoutHost(url) {\n  return new URL(url, DUMMY_ORIGIN);\n}\nfunction _getPathname(url) {\n  return getUrlWithoutHost(url).pathname;\n}\nfunction _isFullStringUrl(url) {\n  return /https?:\\/\\//.test(url);\n}\nfunction _parseUrl(url) {\n  var parsed = undefined;\n  try {\n    parsed = new URL(url, DUMMY_ORIGIN);\n  } catch (_unused) {}\n  return parsed;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3VybC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRixDQUFDLEtBQUtDLENBSUwsQ0FBQztBQUNGLFNBQVNJLE9BQU9BLENBQUNDLE1BQU0sRUFBRUMsR0FBRyxFQUFFO0VBQzFCLEtBQUksSUFBSUMsSUFBSSxJQUFJRCxHQUFHLEVBQUNWLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDUSxNQUFNLEVBQUVFLElBQUksRUFBRTtJQUNwREMsVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRUgsR0FBRyxDQUFDQyxJQUFJO0VBQ2pCLENBQUMsQ0FBQztBQUNOO0FBQ0FILE9BQU8sQ0FBQ04sT0FBTyxFQUFFO0VBQ2JHLFdBQVcsRUFBRSxTQUFBQSxZQUFBLEVBQVc7SUFDcEIsT0FBT0EsWUFBVztFQUN0QixDQUFDO0VBQ0RDLGVBQWUsRUFBRSxTQUFBQSxnQkFBQSxFQUFXO0lBQ3hCLE9BQU9BLGdCQUFlO0VBQzFCLENBQUM7RUFDREMsUUFBUSxFQUFFLFNBQUFBLFNBQUEsRUFBVztJQUNqQixPQUFPQSxTQUFRO0VBQ25CO0FBQ0osQ0FBQyxDQUFDO0FBQ0YsSUFBTU8sWUFBWSxHQUFHLFVBQVU7QUFDL0IsU0FBU0MsaUJBQWlCQSxDQUFDQyxHQUFHLEVBQUU7RUFDNUIsT0FBTyxJQUFJQyxHQUFHLENBQUNELEdBQUcsRUFBRUYsWUFBWSxDQUFDO0FBQ3JDO0FBQ0EsU0FBU1QsWUFBV0EsQ0FBQ1csR0FBRyxFQUFFO0VBQ3RCLE9BQU9ELGlCQUFpQixDQUFDQyxHQUFHLENBQUMsQ0FBQ0UsUUFBUTtBQUMxQztBQUNBLFNBQVNaLGdCQUFlQSxDQUFDVSxHQUFHLEVBQUU7RUFDMUIsT0FBTyxhQUFhLENBQUNHLElBQUksQ0FBQ0gsR0FBRyxDQUFDO0FBQ2xDO0FBQ0EsU0FBU1QsU0FBUUEsQ0FBQ1MsR0FBRyxFQUFFO0VBQ25CLElBQUlJLE1BQU0sR0FBR0MsU0FBUztFQUN0QixJQUFJO0lBQ0FELE1BQU0sR0FBRyxJQUFJSCxHQUFHLENBQUNELEdBQUcsRUFBRUYsWUFBWSxDQUFDO0VBQ3ZDLENBQUMsQ0FBQyxPQUFBUSxPQUFBLEVBQU8sQ0FBQztFQUNWLE9BQU9GLE1BQU07QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvdXJsLmpzPzgyYWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRQYXRobmFtZTogbnVsbCxcbiAgICBpc0Z1bGxTdHJpbmdVcmw6IG51bGwsXG4gICAgcGFyc2VVcmw6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZ2V0UGF0aG5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGF0aG5hbWU7XG4gICAgfSxcbiAgICBpc0Z1bGxTdHJpbmdVcmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNGdWxsU3RyaW5nVXJsO1xuICAgIH0sXG4gICAgcGFyc2VVcmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VVcmw7XG4gICAgfVxufSk7XG5jb25zdCBEVU1NWV9PUklHSU4gPSBcImh0dHA6Ly9uXCI7XG5mdW5jdGlvbiBnZXRVcmxXaXRob3V0SG9zdCh1cmwpIHtcbiAgICByZXR1cm4gbmV3IFVSTCh1cmwsIERVTU1ZX09SSUdJTik7XG59XG5mdW5jdGlvbiBnZXRQYXRobmFtZSh1cmwpIHtcbiAgICByZXR1cm4gZ2V0VXJsV2l0aG91dEhvc3QodXJsKS5wYXRobmFtZTtcbn1cbmZ1bmN0aW9uIGlzRnVsbFN0cmluZ1VybCh1cmwpIHtcbiAgICByZXR1cm4gL2h0dHBzPzpcXC9cXC8vLnRlc3QodXJsKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICAgIGxldCBwYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkID0gbmV3IFVSTCh1cmwsIERVTU1ZX09SSUdJTik7XG4gICAgfSBjYXRjaCAge31cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0UGF0aG5hbWUiLCJpc0Z1bGxTdHJpbmdVcmwiLCJwYXJzZVVybCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIkRVTU1ZX09SSUdJTiIsImdldFVybFdpdGhvdXRIb3N0IiwidXJsIiwiVVJMIiwicGF0aG5hbWUiLCJ0ZXN0IiwicGFyc2VkIiwidW5kZWZpbmVkIiwiX3VudXNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/lib/url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/app-render/dynamic-rendering.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/server/app-render/dynamic-rendering.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */ // Once postpone is in stable we should switch to importing the postpone export directly\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  Postpone: function Postpone() {\n    return _Postpone;\n  },\n  createPostponedAbortSignal: function createPostponedAbortSignal() {\n    return _createPostponedAbortSignal;\n  },\n  createPrerenderState: function createPrerenderState() {\n    return _createPrerenderState;\n  },\n  formatDynamicAPIAccesses: function formatDynamicAPIAccesses() {\n    return _formatDynamicAPIAccesses;\n  },\n  markCurrentScopeAsDynamic: function markCurrentScopeAsDynamic() {\n    return _markCurrentScopeAsDynamic;\n  },\n  trackDynamicDataAccessed: function trackDynamicDataAccessed() {\n    return _trackDynamicDataAccessed;\n  },\n  trackDynamicFetch: function trackDynamicFetch() {\n    return _trackDynamicFetch;\n  },\n  usedDynamicAPIs: function usedDynamicAPIs() {\n    return _usedDynamicAPIs;\n  }\n});\nvar _react = /*#__PURE__*/_interop_require_default(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _hooksservercontext = __webpack_require__(/*! ../../client/components/hooks-server-context */ \"(app-pages-browser)/./node_modules/next/dist/client/components/hooks-server-context.js\");\nvar _staticgenerationbailout = __webpack_require__(/*! ../../client/components/static-generation-bailout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/static-generation-bailout.js\");\nvar _url = __webpack_require__(/*! ../../lib/url */ \"(app-pages-browser)/./node_modules/next/dist/lib/url.js\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar hasPostpone = typeof _react[\"default\"].unstable_postpone === \"function\";\nfunction _createPrerenderState(isDebugSkeleton) {\n  return {\n    isDebugSkeleton: isDebugSkeleton,\n    dynamicAccesses: []\n  };\n}\nfunction _markCurrentScopeAsDynamic(store, expression) {\n  var pathname = (0, _url.getPathname)(store.urlPathname);\n  if (store.isUnstableCacheCallback) {\n    // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n    // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n    // forbidden inside a cache scope.\n    return;\n  } else if (store.dynamicShouldError) {\n    throw new _staticgenerationbailout.StaticGenBailoutError(\"Route \".concat(pathname, \" with `dynamic = \\\"error\\\"` couldn't be rendered statically because it used `\").concat(expression, \"`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\"));\n  } else if (\n  // We are in a prerender (PPR enabled, during build)\n  store.prerenderState) {\n    // We track that we had a dynamic scope that postponed.\n    // This will be used by the renderer to decide whether\n    // the prerender requires a resume\n    postponeWithTracking(store.prerenderState, expression, pathname);\n  } else {\n    store.revalidate = 0;\n    if (store.isStaticGeneration) {\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      var err = new _hooksservercontext.DynamicServerError(\"Route \".concat(pathname, \" couldn't be rendered statically because it used \").concat(expression, \". See more info here: https://nextjs.org/docs/messages/dynamic-server-error\"));\n      store.dynamicUsageDescription = expression;\n      store.dynamicUsageStack = err.stack;\n      throw err;\n    }\n  }\n}\nfunction _trackDynamicDataAccessed(store, expression) {\n  var pathname = (0, _url.getPathname)(store.urlPathname);\n  if (store.isUnstableCacheCallback) {\n    throw new Error(\"Route \".concat(pathname, \" used \\\"\").concat(expression, \"\\\" inside a function cached with \\\"unstable_cache(...)\\\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\\"\").concat(expression, \"\\\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache\"));\n  } else if (store.dynamicShouldError) {\n    throw new _staticgenerationbailout.StaticGenBailoutError(\"Route \".concat(pathname, \" with `dynamic = \\\"error\\\"` couldn't be rendered statically because it used `\").concat(expression, \"`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering\"));\n  } else if (\n  // We are in a prerender (PPR enabled, during build)\n  store.prerenderState) {\n    // We track that we had a dynamic scope that postponed.\n    // This will be used by the renderer to decide whether\n    // the prerender requires a resume\n    postponeWithTracking(store.prerenderState, expression, pathname);\n  } else {\n    store.revalidate = 0;\n    if (store.isStaticGeneration) {\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      var err = new _hooksservercontext.DynamicServerError(\"Route \".concat(pathname, \" couldn't be rendered statically because it used `\").concat(expression, \"`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error\"));\n      store.dynamicUsageDescription = expression;\n      store.dynamicUsageStack = err.stack;\n      throw err;\n    }\n  }\n}\nfunction _Postpone(_ref) {\n  var reason = _ref.reason,\n    prerenderState = _ref.prerenderState,\n    pathname = _ref.pathname;\n  postponeWithTracking(prerenderState, reason, pathname);\n}\nfunction _trackDynamicFetch(store, expression) {\n  if (store.prerenderState) {\n    postponeWithTracking(store.prerenderState, expression, store.urlPathname);\n  }\n}\nfunction postponeWithTracking(prerenderState, expression, pathname) {\n  assertPostpone();\n  var reason = \"Route \".concat(pathname, \" needs to bail out of prerendering at this point because it used \").concat(expression, \". \") + \"React throws this special object to indicate where. It should not be caught by \" + \"your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error\";\n  prerenderState.dynamicAccesses.push({\n    // When we aren't debugging, we don't need to create another error for the\n    // stack trace.\n    stack: prerenderState.isDebugSkeleton ? new Error().stack : undefined,\n    expression: expression\n  });\n  _react[\"default\"].unstable_postpone(reason);\n}\nfunction _usedDynamicAPIs(prerenderState) {\n  return prerenderState.dynamicAccesses.length > 0;\n}\nfunction _formatDynamicAPIAccesses(prerenderState) {\n  return prerenderState.dynamicAccesses.filter(function (access) {\n    return typeof access.stack === \"string\" && access.stack.length > 0;\n  }).map(function (_ref2) {\n    var expression = _ref2.expression,\n      stack = _ref2.stack;\n    stack = stack.split(\"\\n\") // Remove the \"Error: \" prefix from the first line of the stack trace as\n    // well as the first 4 lines of the stack trace which is the distance\n    // from the user code and the `new Error().stack` call.\n    .slice(4).filter(function (line) {\n      // Exclude Next.js internals from the stack trace.\n      if (line.includes(\"node_modules/next/\")) {\n        return false;\n      }\n      // Exclude anonymous functions from the stack trace.\n      if (line.includes(\" (<anonymous>)\")) {\n        return false;\n      }\n      // Exclude Node.js internals from the stack trace.\n      if (line.includes(\" (node:\")) {\n        return false;\n      }\n      return true;\n    }).join(\"\\n\");\n    return \"Dynamic API Usage Debug - \".concat(expression, \":\\n\").concat(stack);\n  });\n}\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\"Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js\");\n  }\n}\nfunction _createPostponedAbortSignal(reason) {\n  assertPostpone();\n  var controller = new AbortController();\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    _react[\"default\"].unstable_postpone(reason);\n  } catch (x) {\n    controller.abort(x);\n  }\n  return controller.signal;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBcEJBLENBb0JJO0FBQ1M7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsQ0FBQyxLQUFLQyxDQVNMLENBQUM7QUFDRixTQUFTUyxPQUFPQSxDQUFDQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtFQUMxQixLQUFJLElBQUlDLElBQUksSUFBSUQsR0FBRyxFQUFDZixNQUFNLENBQUNDLGNBQWMsQ0FBQ2EsTUFBTSxFQUFFRSxJQUFJLEVBQUU7SUFDcERDLFVBQVUsRUFBRSxJQUFJO0lBQ2hCQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBSTtFQUNqQixDQUFDLENBQUM7QUFDTjtBQUNBSCxPQUFPLENBQUNYLE9BQU8sRUFBRTtFQUNiRyxRQUFRLEVBQUUsU0FBQUEsU0FBQSxFQUFXO0lBQ2pCLE9BQU9BLFNBQVE7RUFDbkIsQ0FBQztFQUNEQywwQkFBMEIsRUFBRSxTQUFBQSwyQkFBQSxFQUFXO0lBQ25DLE9BQU9BLDJCQUEwQjtFQUNyQyxDQUFDO0VBQ0RDLG9CQUFvQixFQUFFLFNBQUFBLHFCQUFBLEVBQVc7SUFDN0IsT0FBT0EscUJBQW9CO0VBQy9CLENBQUM7RUFDREMsd0JBQXdCLEVBQUUsU0FBQUEseUJBQUEsRUFBVztJQUNqQyxPQUFPQSx5QkFBd0I7RUFDbkMsQ0FBQztFQUNEQyx5QkFBeUIsRUFBRSxTQUFBQSwwQkFBQSxFQUFXO0lBQ2xDLE9BQU9BLDBCQUF5QjtFQUNwQyxDQUFDO0VBQ0RDLHdCQUF3QixFQUFFLFNBQUFBLHlCQUFBLEVBQVc7SUFD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QTtNQUNBLElBQUlELElBQUksQ0FBQ0MsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7UUFDakMsT0FBTyxLQUFLO01BQ2hCO01BQ0E7TUFDQSxJQUFJRCxJQUFJLENBQUNDLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUMxQixPQUFPLEtBQUs7TUFDaEI7TUFDQSxPQUFPLElBQUk7SUFDZixDQUFDLENBQUMsQ0FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNiLG9DQUFBekIsTUFBQSxDQUFvQ1AsVUFBVSxTQUFBTyxNQUFBLENBQU1TLEtBQUs7RUFDN0QsQ0FBQyxDQUFDO0FBQ047QUFDQSxTQUFTSSxjQUFjQSxDQUFBLEVBQUc7RUFDdEIsSUFBSSxDQUFDekIsV0FBVyxFQUFFO0lBQ2QsTUFBTSxJQUFJc0IsS0FBSyxtSUFBbUksQ0FBQztFQUN2SjtBQUNKO0FBQ0EsU0FBUzNDLDJCQUEwQkEsQ0FBQzZDLE1BQU0sRUFBRTtFQUN4Q0MsY0FBYyxDQUFDLENBQUM7RUFDaEIsSUFBTWEsVUFBVSxHQUFHLElBQUlDLGVBQWUsQ0FBQyxDQUFDO0VBQ3hDO0VBQ0EsSUFBSTtJQUNBL0MsTUFBTSxXQUFRLENBQUNTLGlCQUFpQixDQUFDdUIsTUFBTSxDQUFDO0VBQzVDLENBQUMsQ0FBQyxPQUFPZ0IsQ0FBQyxFQUFFO0lBQ1JGLFVBQVUsQ0FBQ0csS0FBSyxDQUFDRCxDQUFDLENBQUM7RUFDdkI7RUFDQSxPQUFPRixVQUFVLENBQUNJLE1BQU07QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZy5qcz8xNDMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIGZ1bmN0aW9ucyBwcm92aWRlZCBieSB0aGlzIG1vZHVsZSBhcmUgdXNlZCB0byBjb21tdW5pY2F0ZSBjZXJ0YWluIHByb3BlcnRpZXNcbiAqIGFib3V0IHRoZSBjdXJyZW50bHkgcnVubmluZyBjb2RlIHNvIHRoYXQgTmV4dC5qcyBjYW4gbWFrZSBkZWNpc2lvbnMgb24gaG93IHRvIGhhbmRsZVxuICogdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGluIGRpZmZlcmVudCByZW5kZXJpbmcgbW9kZXMgc3VjaCBhcyBwcmUtcmVuZGVyaW5nLCByZXN1bWluZywgYW5kIFNTUi5cbiAqXG4gKiBUb2RheSBOZXh0LmpzIHRyZWF0cyBhbGwgY29kZSBhcyBwb3RlbnRpYWxseSBzdGF0aWMuIENlcnRhaW4gQVBJcyBtYXkgb25seSBtYWtlIHNlbnNlIHdoZW4gZHluYW1pY2FsbHkgcmVuZGVyaW5nLlxuICogVHJhZGl0aW9uYWxseSB0aGlzIG1lYW50IGRlb3B0aW5nIHRoZSBlbnRpcmUgcmVuZGVyIHRvIGR5bmFtaWMgaG93ZXZlciB3aXRoIFBQUiB3ZSBjYW4gbm93IGRlb3B0IHBhcnRzXG4gKiBvZiBhIFJlYWN0IHRyZWUgYXMgZHluYW1pYyB3aGlsZSBzdGlsbCBrZWVwaW5nIG90aGVyIHBhcnRzIHN0YXRpYy4gVGhlcmUgYXJlIHJlYWxseSB0d28gZGlmZmVyZW50IGtpbmRzIG9mXG4gKiBEeW5hbWljIGluZGljYXRpb25zLlxuICpcbiAqIFRoZSBmaXJzdCBpcyBzaW1wbHkgYW4gaW50ZW50aW9uIHRvIGJlIGR5bmFtaWMuIHVuc3RhYmxlX25vU3RvcmUgaXMgYW4gZXhhbXBsZSBvZiB0aGlzIHdoZXJlXG4gKiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBjb2RlIHNpbXBseSBkZWNsYXJlcyB0aGF0IHRoZSBjdXJyZW50IHNjb3BlIGlzIGR5bmFtaWMgYnV0IGlmIHlvdSB1c2UgaXRcbiAqIGluc2lkZSB1bnN0YWJsZV9jYWNoZSBpdCBjYW4gc3RpbGwgYmUgY2FjaGVkLiBUaGlzIHR5cGUgb2YgaW5kaWNhdGlvbiBjYW4gYmUgcmVtb3ZlZCBpZiB3ZSBldmVyXG4gKiBtYWtlIHRoZSBkZWZhdWx0IGR5bmFtaWMgdG8gYmVnaW4gd2l0aCBiZWNhdXNlIHRoZSBvbmx5IHdheSB5b3Ugd291bGQgZXZlciBiZSBzdGF0aWMgaXMgaW5zaWRlXG4gKiBhIGNhY2hlIHNjb3BlIHdoaWNoIHRoaXMgaW5kaWNhdGlvbiBkb2VzIG5vdCBhZmZlY3QuXG4gKlxuICogVGhlIHNlY29uZCBpcyBhbiBpbmRpY2F0aW9uIHRoYXQgYSBkeW5hbWljIGRhdGEgc291cmNlIHdhcyByZWFkLiBUaGlzIGlzIGEgc3Ryb25nZXIgZm9ybSBvZiBkeW5hbWljXG4gKiBiZWNhdXNlIGl0IG1lYW5zIHRoYXQgaXQgaXMgaW5hcHByb3ByaWF0ZSB0byBjYWNoZSB0aGlzIGF0IGFsbC4gdXNpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlIGluc2lkZVxuICogdW5zdGFibGVfY2FjaGUgc2hvdWxkIGVycm9yLiBJZiB5b3Ugd2FudCB0byB1c2Ugc29tZSBkeW5hbWljIGRhdGEgaW5zaWRlIHVuc3RhYmxlX2NhY2hlIHlvdSBzaG91bGRcbiAqIHJlYWQgdGhhdCBkYXRhIG91dHNpZGUgdGhlIGNhY2hlIGFuZCBwYXNzIGl0IGluIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjYWNoZWQgZnVuY3Rpb24uXG4gKi8gLy8gT25jZSBwb3N0cG9uZSBpcyBpbiBzdGFibGUgd2Ugc2hvdWxkIHN3aXRjaCB0byBpbXBvcnRpbmcgdGhlIHBvc3Rwb25lIGV4cG9ydCBkaXJlY3RseVxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQb3N0cG9uZTogbnVsbCxcbiAgICBjcmVhdGVQb3N0cG9uZWRBYm9ydFNpZ25hbDogbnVsbCxcbiAgICBjcmVhdGVQcmVyZW5kZXJTdGF0ZTogbnVsbCxcbiAgICBmb3JtYXREeW5hbWljQVBJQWNjZXNzZXM6IG51bGwsXG4gICAgbWFya0N1cnJlbnRTY29wZUFzRHluYW1pYzogbnVsbCxcbiAgICB0cmFja0R5bmFtaWNEYXRhQWNjZXNzZWQ6IG51bGwsXG4gICAgdHJhY2tEeW5hbWljRmV0Y2g6IG51bGwsXG4gICAgdXNlZER5bmFtaWNBUElzOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIFBvc3Rwb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBvc3Rwb25lO1xuICAgIH0sXG4gICAgY3JlYXRlUG9zdHBvbmVkQWJvcnRTaWduYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9zdHBvbmVkQWJvcnRTaWduYWw7XG4gICAgfSxcbiAgICBjcmVhdGVQcmVyZW5kZXJTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJTdGF0ZTtcbiAgICB9LFxuICAgIGZvcm1hdER5bmFtaWNBUElBY2Nlc3NlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXREeW5hbWljQVBJQWNjZXNzZXM7XG4gICAgfSxcbiAgICBtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtDdXJyZW50U2NvcGVBc0R5bmFtaWM7XG4gICAgfSxcbiAgICB0cmFja0R5bmFtaWNEYXRhQWNjZXNzZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJhY2tEeW5hbWljRGF0YUFjY2Vzc2VkO1xuICAgIH0sXG4gICAgdHJhY2tEeW5hbWljRmV0Y2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJhY2tEeW5hbWljRmV0Y2g7XG4gICAgfSxcbiAgICB1c2VkRHluYW1pY0FQSXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlZER5bmFtaWNBUElzO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9ob29rc3NlcnZlcmNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHRcIik7XG5jb25zdCBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dFwiKTtcbmNvbnN0IF91cmwgPSByZXF1aXJlKFwiLi4vLi4vbGliL3VybFwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuY29uc3QgaGFzUG9zdHBvbmUgPSB0eXBlb2YgX3JlYWN0LmRlZmF1bHQudW5zdGFibGVfcG9zdHBvbmUgPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclN0YXRlKGlzRGVidWdTa2VsZXRvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzRGVidWdTa2VsZXRvbixcbiAgICAgICAgZHluYW1pY0FjY2Vzc2VzOiBbXVxuICAgIH07XG59XG5mdW5jdGlvbiBtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljKHN0b3JlLCBleHByZXNzaW9uKSB7XG4gICAgY29uc3QgcGF0aG5hbWUgPSAoMCwgX3VybC5nZXRQYXRobmFtZSkoc3RvcmUudXJsUGF0aG5hbWUpO1xuICAgIGlmIChzdG9yZS5pc1Vuc3RhYmxlQ2FjaGVDYWxsYmFjaykge1xuICAgICAgICAvLyBpbnNpZGUgY2FjaGUgc2NvcGVzIG1hcmtpbmcgYSBzY29wZSBhcyBkeW5hbWljIGhhcyBubyBlZmZlY3QgYmVjYXVzZSB0aGUgb3V0ZXIgY2FjaGUgc2NvcGVcbiAgICAgICAgLy8gY3JlYXRlcyBhIGNhY2hlIGJvdW5kYXJ5LiBUaGlzIGlzIHN1YnRseSBkaWZmZXJlbnQgZnJvbSByZWFkaW5nIGEgZHluYW1pYyBkYXRhIHNvdXJjZSB3aGljaCBpc1xuICAgICAgICAvLyBmb3JiaWRkZW4gaW5zaWRlIGEgY2FjaGUgc2NvcGUuXG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0LlN0YXRpY0dlbkJhaWxvdXRFcnJvcihgUm91dGUgJHtwYXRobmFtZX0gd2l0aCBcXGBkeW5hbWljID0gXCJlcnJvclwiXFxgIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkIFxcYCR7ZXhwcmVzc2lvbn1cXGAuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2ApO1xuICAgIH0gZWxzZSBpZiAoLy8gV2UgYXJlIGluIGEgcHJlcmVuZGVyIChQUFIgZW5hYmxlZCwgZHVyaW5nIGJ1aWxkKVxuICAgIHN0b3JlLnByZXJlbmRlclN0YXRlKSB7XG4gICAgICAgIC8vIFdlIHRyYWNrIHRoYXQgd2UgaGFkIGEgZHluYW1pYyBzY29wZSB0aGF0IHBvc3Rwb25lZC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHVzZWQgYnkgdGhlIHJlbmRlcmVyIHRvIGRlY2lkZSB3aGV0aGVyXG4gICAgICAgIC8vIHRoZSBwcmVyZW5kZXIgcmVxdWlyZXMgYSByZXN1bWVcbiAgICAgICAgcG9zdHBvbmVXaXRoVHJhY2tpbmcoc3RvcmUucHJlcmVuZGVyU3RhdGUsIGV4cHJlc3Npb24sIHBhdGhuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5yZXZhbGlkYXRlID0gMDtcbiAgICAgICAgaWYgKHN0b3JlLmlzU3RhdGljR2VuZXJhdGlvbikge1xuICAgICAgICAgICAgLy8gV2UgYXJlbid0IHByZXJlbmRlcmluZyBidXQgd2UgYXJlIGdlbmVyYXRpbmcgYSBzdGF0aWMgcGFnZS4gV2UgbmVlZCB0byBiYWlsIG91dCBvZiBzdGF0aWMgZ2VuZXJhdGlvblxuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IF9ob29rc3NlcnZlcmNvbnRleHQuRHluYW1pY1NlcnZlckVycm9yKGBSb3V0ZSAke3BhdGhuYW1lfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2R5bmFtaWMtc2VydmVyLWVycm9yYCk7XG4gICAgICAgICAgICBzdG9yZS5keW5hbWljVXNhZ2VEZXNjcmlwdGlvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgICBzdG9yZS5keW5hbWljVXNhZ2VTdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZChzdG9yZSwgZXhwcmVzc2lvbikge1xuICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF91cmwuZ2V0UGF0aG5hbWUpKHN0b3JlLnVybFBhdGhuYW1lKTtcbiAgICBpZiAoc3RvcmUuaXNVbnN0YWJsZUNhY2hlQ2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb3V0ZSAke3BhdGhuYW1lfSB1c2VkIFwiJHtleHByZXNzaW9ufVwiIGluc2lkZSBhIGZ1bmN0aW9uIGNhY2hlZCB3aXRoIFwidW5zdGFibGVfY2FjaGUoLi4uKVwiLiBBY2Nlc3NpbmcgRHluYW1pYyBkYXRhIHNvdXJjZXMgaW5zaWRlIGEgY2FjaGUgc2NvcGUgaXMgbm90IHN1cHBvcnRlZC4gSWYgeW91IG5lZWQgdGhpcyBkYXRhIGluc2lkZSBhIGNhY2hlZCBmdW5jdGlvbiB1c2UgXCIke2V4cHJlc3Npb259XCIgb3V0c2lkZSBvZiB0aGUgY2FjaGVkIGZ1bmN0aW9uIGFuZCBwYXNzIHRoZSByZXF1aXJlZCBkeW5hbWljIGRhdGEgaW4gYXMgYW4gYXJndW1lbnQuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3Vuc3RhYmxlX2NhY2hlYCk7XG4gICAgfSBlbHNlIGlmIChzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9zdGF0aWNnZW5lcmF0aW9uYmFpbG91dC5TdGF0aWNHZW5CYWlsb3V0RXJyb3IoYFJvdXRlICR7cGF0aG5hbWV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgKTtcbiAgICB9IGVsc2UgaWYgKC8vIFdlIGFyZSBpbiBhIHByZXJlbmRlciAoUFBSIGVuYWJsZWQsIGR1cmluZyBidWlsZClcbiAgICBzdG9yZS5wcmVyZW5kZXJTdGF0ZSkge1xuICAgICAgICAvLyBXZSB0cmFjayB0aGF0IHdlIGhhZCBhIGR5bmFtaWMgc2NvcGUgdGhhdCBwb3N0cG9uZWQuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIGJ5IHRoZSByZW5kZXJlciB0byBkZWNpZGUgd2hldGhlclxuICAgICAgICAvLyB0aGUgcHJlcmVuZGVyIHJlcXVpcmVzIGEgcmVzdW1lXG4gICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKHN0b3JlLnByZXJlbmRlclN0YXRlLCBleHByZXNzaW9uLCBwYXRobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUucmV2YWxpZGF0ZSA9IDA7XG4gICAgICAgIGlmIChzdG9yZS5pc1N0YXRpY0dlbmVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBwcmVyZW5kZXJpbmcgYnV0IHdlIGFyZSBnZW5lcmF0aW5nIGEgc3RhdGljIHBhZ2UuIFdlIG5lZWQgdG8gYmFpbCBvdXQgb2Ygc3RhdGljIGdlbmVyYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBfaG9va3NzZXJ2ZXJjb250ZXh0LkR5bmFtaWNTZXJ2ZXJFcnJvcihgUm91dGUgJHtwYXRobmFtZX0gY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgXFxgJHtleHByZXNzaW9ufVxcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9keW5hbWljLXNlcnZlci1lcnJvcmApO1xuICAgICAgICAgICAgc3RvcmUuZHluYW1pY1VzYWdlRGVzY3JpcHRpb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBQb3N0cG9uZSh7IHJlYXNvbiwgcHJlcmVuZGVyU3RhdGUsIHBhdGhuYW1lIH0pIHtcbiAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhwcmVyZW5kZXJTdGF0ZSwgcmVhc29uLCBwYXRobmFtZSk7XG59XG5mdW5jdGlvbiB0cmFja0R5bmFtaWNGZXRjaChzdG9yZSwgZXhwcmVzc2lvbikge1xuICAgIGlmIChzdG9yZS5wcmVyZW5kZXJTdGF0ZSkge1xuICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhzdG9yZS5wcmVyZW5kZXJTdGF0ZSwgZXhwcmVzc2lvbiwgc3RvcmUudXJsUGF0aG5hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc3Rwb25lV2l0aFRyYWNraW5nKHByZXJlbmRlclN0YXRlLCBleHByZXNzaW9uLCBwYXRobmFtZSkge1xuICAgIGFzc2VydFBvc3Rwb25lKCk7XG4gICAgY29uc3QgcmVhc29uID0gYFJvdXRlICR7cGF0aG5hbWV9IG5lZWRzIHRvIGJhaWwgb3V0IG9mIHByZXJlbmRlcmluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LiBgICsgYFJlYWN0IHRocm93cyB0aGlzIHNwZWNpYWwgb2JqZWN0IHRvIGluZGljYXRlIHdoZXJlLiBJdCBzaG91bGQgbm90IGJlIGNhdWdodCBieSBgICsgYHlvdXIgb3duIHRyeS9jYXRjaC4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHByLWNhdWdodC1lcnJvcmA7XG4gICAgcHJlcmVuZGVyU3RhdGUuZHluYW1pY0FjY2Vzc2VzLnB1c2goe1xuICAgICAgICAvLyBXaGVuIHdlIGFyZW4ndCBkZWJ1Z2dpbmcsIHdlIGRvbid0IG5lZWQgdG8gY3JlYXRlIGFub3RoZXIgZXJyb3IgZm9yIHRoZVxuICAgICAgICAvLyBzdGFjayB0cmFjZS5cbiAgICAgICAgc3RhY2s6IHByZXJlbmRlclN0YXRlLmlzRGVidWdTa2VsZXRvbiA/IG5ldyBFcnJvcigpLnN0YWNrIDogdW5kZWZpbmVkLFxuICAgICAgICBleHByZXNzaW9uXG4gICAgfSk7XG4gICAgX3JlYWN0LmRlZmF1bHQudW5zdGFibGVfcG9zdHBvbmUocmVhc29uKTtcbn1cbmZ1bmN0aW9uIHVzZWREeW5hbWljQVBJcyhwcmVyZW5kZXJTdGF0ZSkge1xuICAgIHJldHVybiBwcmVyZW5kZXJTdGF0ZS5keW5hbWljQWNjZXNzZXMubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIGZvcm1hdER5bmFtaWNBUElBY2Nlc3NlcyhwcmVyZW5kZXJTdGF0ZSkge1xuICAgIHJldHVybiBwcmVyZW5kZXJTdGF0ZS5keW5hbWljQWNjZXNzZXMuZmlsdGVyKChhY2Nlc3MpPT50eXBlb2YgYWNjZXNzLnN0YWNrID09PSBcInN0cmluZ1wiICYmIGFjY2Vzcy5zdGFjay5sZW5ndGggPiAwKS5tYXAoKHsgZXhwcmVzc2lvbiwgc3RhY2sgfSk9PntcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zcGxpdChcIlxcblwiKS8vIFJlbW92ZSB0aGUgXCJFcnJvcjogXCIgcHJlZml4IGZyb20gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIHN0YWNrIHRyYWNlIGFzXG4gICAgICAgIC8vIHdlbGwgYXMgdGhlIGZpcnN0IDQgbGluZXMgb2YgdGhlIHN0YWNrIHRyYWNlIHdoaWNoIGlzIHRoZSBkaXN0YW5jZVxuICAgICAgICAvLyBmcm9tIHRoZSB1c2VyIGNvZGUgYW5kIHRoZSBgbmV3IEVycm9yKCkuc3RhY2tgIGNhbGwuXG4gICAgICAgIC5zbGljZSg0KS5maWx0ZXIoKGxpbmUpPT57XG4gICAgICAgICAgICAvLyBFeGNsdWRlIE5leHQuanMgaW50ZXJuYWxzIGZyb20gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoXCJub2RlX21vZHVsZXMvbmV4dC9cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeGNsdWRlIGFub255bW91cyBmdW5jdGlvbnMgZnJvbSB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcyhcIiAoPGFub255bW91cz4pXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhjbHVkZSBOb2RlLmpzIGludGVybmFscyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKFwiIChub2RlOlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgICAgICByZXR1cm4gYER5bmFtaWMgQVBJIFVzYWdlIERlYnVnIC0gJHtleHByZXNzaW9ufTpcXG4ke3N0YWNrfWA7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnRQb3N0cG9uZSgpIHtcbiAgICBpZiAoIWhhc1Bvc3Rwb25lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YXJpYW50OiBSZWFjdC51bnN0YWJsZV9wb3N0cG9uZSBpcyBub3QgZGVmaW5lZC4gVGhpcyBzdWdnZXN0cyB0aGUgd3JvbmcgdmVyc2lvbiBvZiBSZWFjdCB3YXMgbG9hZGVkLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanNgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3N0cG9uZWRBYm9ydFNpZ25hbChyZWFzb24pIHtcbiAgICBhc3NlcnRQb3N0cG9uZSgpO1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgLy8gV2UgZ2V0IG91ciBoYW5kcyBvbiBhIHBvc3Rwb25lIGluc3RhbmNlIGJ5IGNhbGxpbmcgcG9zdHBvbmUgYW5kIGNhdGNoaW5nIHRoZSB0aHJvd1xuICAgIHRyeSB7XG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnVuc3RhYmxlX3Bvc3Rwb25lKHJlYXNvbik7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KHgpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR5bmFtaWMtcmVuZGVyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIlBvc3Rwb25lIiwiY3JlYXRlUG9zdHBvbmVkQWJvcnRTaWduYWwiLCJjcmVhdGVQcmVyZW5kZXJTdGF0ZSIsImZvcm1hdER5bmFtaWNBUElBY2Nlc3NlcyIsIm1hcmtDdXJyZW50U2NvcGVBc0R5bmFtaWMiLCJ0cmFja0R5bmFtaWNEYXRhQWNjZXNzZWQiLCJ0cmFja0R5bmFtaWNGZXRjaCIsInVzZWREeW5hbWljQVBJcyIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9yZWFjdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaG9va3NzZXJ2ZXJjb250ZXh0IiwiX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0IiwiX3VybCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJoYXNQb3N0cG9uZSIsInVuc3RhYmxlX3Bvc3Rwb25lIiwiaXNEZWJ1Z1NrZWxldG9uIiwiZHluYW1pY0FjY2Vzc2VzIiwic3RvcmUiLCJleHByZXNzaW9uIiwicGF0aG5hbWUiLCJnZXRQYXRobmFtZSIsInVybFBhdGhuYW1lIiwiaXNVbnN0YWJsZUNhY2hlQ2FsbGJhY2siLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJjb25jYXQiLCJwcmVyZW5kZXJTdGF0ZSIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwicmV2YWxpZGF0ZSIsImlzU3RhdGljR2VuZXJhdGlvbiIsImVyciIsIkR5bmFtaWNTZXJ2ZXJFcnJvciIsImR5bmFtaWNVc2FnZURlc2NyaXB0aW9uIiwiZHluYW1pY1VzYWdlU3RhY2siLCJzdGFjayIsIkVycm9yIiwiX3JlZiIsInJlYXNvbiIsImFzc2VydFBvc3Rwb25lIiwicHVzaCIsInVuZGVmaW5lZCIsImxlbmd0aCIsImZpbHRlciIsImFjY2VzcyIsIm1hcCIsIl9yZWYyIiwic3BsaXQiLCJzbGljZSIsImxpbmUiLCJpbmNsdWRlcyIsImpvaW4iLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwieCIsImFib3J0Iiwic2lnbmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"ReflectAdapter\", ({\n  enumerable: true,\n  get: function get() {\n    return ReflectAdapter;\n  }\n}));\nvar ReflectAdapter = /*#__PURE__*/function () {\n  function ReflectAdapter() {\n    _classCallCheck(this, ReflectAdapter);\n  }\n  _createClass(ReflectAdapter, null, [{\n    key: \"get\",\n    value: function get(target, prop, receiver) {\n      var value = Reflect.get(target, prop, receiver);\n      if (typeof value === \"function\") {\n        return value.bind(target);\n      }\n      return value;\n    }\n  }, {\n    key: \"set\",\n    value: function set(target, prop, value, receiver) {\n      return Reflect.set(target, prop, value, receiver);\n    }\n  }, {\n    key: \"has\",\n    value: function has(target, prop) {\n      return Reflect.has(target, prop);\n    }\n  }, {\n    key: \"deleteProperty\",\n    value: function deleteProperty(target, prop) {\n      return Reflect.deleteProperty(target, prop);\n    }\n  }]);\n  return ReflectAdapter;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUFBLElBQUFBLGVBQUEsR0FBQUMsbUJBQUE7QUFBQSxJQUFBQyxZQUFBLEdBQUFELG1CQUFBO0FBQ2JFLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGtEQUFpRDtFQUM3Q0ksVUFBVSxFQUFFLElBQUk7RUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxJQUFBLEVBQVc7SUFDWixPQUFPQyxjQUFjO0VBQ3pCO0FBQ0osQ0FBQyxFQUFDO0FBQUMsSUFDR0EsY0FBYztFQUFBLFNBQUFBLGVBQUE7SUFBQVQsZUFBQSxPQUFBUyxjQUFBO0VBQUE7RUFBQVAsWUFBQSxDQUFBTyxjQUFBO0lBQUFDLEdBQUE7SUFBQUosS0FBQSxFQUNoQixTQUFBRSxJQUFXRyxNQUFNLEVBQUVDLElBQUksRUFBRUMsUUFBUSxFQUFFO01BQy9CLElBQU1QLEtBQUssR0FBR1EsT0FBTyxDQUFDTixHQUFHLENBQUNHLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRLENBQUM7TUFDakQsSUFBSSxPQUFPUCxLQUFLLEtBQUssVUFBVSxFQUFFO1FBQzdCLE9BQU9BLEtBQUssQ0FBQ1MsSUFBSSxDQUFDSixNQUFNLENBQUM7TUFDN0I7TUFDQSxPQUFPTCxLQUFLO0lBQ2hCO0VBQUM7SUFBQUksR0FBQTtJQUFBSixLQUFBLEVBQ0QsU0FBQVUsSUFBV0wsTUFBTSxFQUFFQyxJQUFJLEVBQUVOLEtBQUssRUFBRU8sUUFBUSxFQUFFO01BQ3RDLE9BQU9DLE9BQU8sQ0FBQ0UsR0FBRyxDQUFDTCxNQUFNLEVBQUVDLElBQUksRUFBRU4sS0FBSyxFQUFFTyxRQUFRLENBQUM7SUFDckQ7RUFBQztJQUFBSCxHQUFBO0lBQUFKLEtBQUEsRUFDRCxTQUFBVyxJQUFXTixNQUFNLEVBQUVDLElBQUksRUFBRTtNQUNyQixPQUFPRSxPQUFPLENBQUNHLEdBQUcsQ0FBQ04sTUFBTSxFQUFFQyxJQUFJLENBQUM7SUFDcEM7RUFBQztJQUFBRixHQUFBO0lBQUFKLEtBQUEsRUFDRCxTQUFBWSxlQUFzQlAsTUFBTSxFQUFFQyxJQUFJLEVBQUU7TUFDaEMsT0FBT0UsT0FBTyxDQUFDSSxjQUFjLENBQUNQLE1BQU0sRUFBRUMsSUFBSSxDQUFDO0lBQy9DO0VBQUM7RUFBQSxPQUFBSCxjQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QuanM/NGNjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlZmxlY3RBZGFwdGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlcjtcbiAgICB9XG59KTtcbmNsYXNzIFJlZmxlY3RBZGFwdGVyIHtcbiAgICBzdGF0aWMgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYmluZCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICB9XG4gICAgc3RhdGljIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdC5qcy5tYXAiXSwibmFtZXMiOlsiX2NsYXNzQ2FsbENoZWNrIiwicmVxdWlyZSIsIl9jcmVhdGVDbGFzcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlJlZmxlY3RBZGFwdGVyIiwia2V5IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImJpbmQiLCJzZXQiLCJoYXMiLCJkZWxldGVQcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-page.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ClientPageRoot\", ({\n    enumerable: true,\n    get: function get() {\n        return ClientPageRoot;\n    }\n}));\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _searchparams = __webpack_require__(/*! ./search-params */ \"(app-pages-browser)/./node_modules/next/dist/client/components/search-params.js\");\nfunction ClientPageRoot(param) {\n    var Component = param.Component, props = param.props;\n    // We expect to be passed searchParams but even if we aren't we can construct one from\n    // an empty object. We only do this if we are in a static generation as a performance\n    // optimization. Ideally we'd unconditionally construct the tracked params but since\n    // this creates a proxy which is slow and this would happen even for client navigations\n    // that are done entirely dynamically and we know there the dynamic tracking is a noop\n    // in this dynamic case we can safely elide it.\n    props.searchParams = (0, _searchparams.createDynamicallyTrackedSearchParams)(props.searchParams || {});\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, _objectSpread({}, props));\n}\n_c1 = ClientPageRoot;\n_c = ClientPageRoot;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n}\nvar _c;\n$RefreshReg$(_c, \"ClientPageRoot\");\nvar _c1;\n$RefreshReg$(_c1, \"ClientPageRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXBhZ2UuanMiLCJtYXBwaW5ncyI6InFEQUVhO0FBQUEsSUFBQUEsa0JBQUFDLG1CQUFBQSxDQUFBO0FBQUEsU0FBQUMsUUFBQUMsQ0FBQSxFQUFBQyxDQUFBO0lBQUEsSUFBQUMsSUFBQUMsT0FBQUMsSUFBQSxDQUFBSjtJQUFBLElBQUFHLE9BQUFFLHFCQUFBO1FBQUEsSUFBQUMsSUFBQUgsT0FBQUUscUJBQUEsQ0FBQUw7UUFBQUMsS0FBQUssQ0FBQUEsSUFBQUEsRUFBQUMsTUFBQSxVQUFBTixDQUFBO1lBQUEsT0FBQUUsT0FBQUssd0JBQUEsQ0FBQVIsR0FBQUMsR0FBQVEsVUFBQTtRQUFBLEtBQUFQLEVBQUFRLElBQUEsQ0FBQUMsS0FBQSxDQUFBVCxHQUFBSTtJQUFBO0lBQUEsT0FBQUo7QUFBQTtBQUFBLFNBQUFVLGNBQUFaLENBQUE7SUFBQSxRQUFBQyxJQUFBLEdBQUFBLElBQUFZLFVBQUFDLE1BQUEsRUFBQWIsSUFBQTtRQUFBLElBQUFDLElBQUEsUUFBQVcsU0FBQSxDQUFBWixFQUFBLEdBQUFZLFNBQUEsQ0FBQVosRUFBQTtRQUFBQSxJQUFBLElBQUFGLFFBQUFJLE9BQUFELElBQUEsSUFBQWEsT0FBQSxVQUFBZCxDQUFBO1lBQUFKLGdCQUFBRyxHQUFBQyxHQUFBQyxDQUFBLENBQUFELEVBQUE7UUFBQSxLQUFBRSxPQUFBYSx5QkFBQSxHQUFBYixPQUFBYyxnQkFBQSxDQUFBakIsR0FBQUcsT0FBQWEseUJBQUEsQ0FBQWQsTUFBQUgsUUFBQUksT0FBQUQsSUFBQWEsT0FBQSxVQUFBZCxDQUFBO1lBQUFFLE9BQUFlLGNBQUEsQ0FBQWxCLEdBQUFDLEdBQUFFLE9BQUFLLHdCQUFBLENBQUFOLEdBQUFEO1FBQUE7SUFBQTtJQUFBLE9BQUFEO0FBQUE7QUFDYkcsOENBQTZDO0lBQ3pDaUIsT0FBTztBQUNYLENBQUMsRUFBQztBQUNGakIsa0RBQWlEO0lBQzdDTSxZQUFZO0lBQ1pZLEtBQUssU0FBQUE7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsSUFBTUMsY0FBY3pCLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxJQUFNMEIsZ0JBQWdCMUIsbUJBQU9BLENBQUMsd0dBQWlCO0FBQy9DLFNBQVN3QixlQUFlRyxLQUFLO0lBQ3pCLElBQU1DLFlBQXFCRCxNQUFyQkMsU0FBUyxFQUFFQyxRQUFVRixNQUFWRSxLQUFLO0lBQ3RCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBQSxNQUFNQyxZQUFZLEdBQUcsQ0FBQyxHQUFHSixjQUFjSyxvQ0FBb0MsRUFBRUYsTUFBTUMsWUFBWSxJQUFJLENBQUM7SUFDcEcsT0FBcUIsV0FBZCxHQUFlLElBQUdMLFlBQVlPLEdBQUcsRUFBRUosV0FBU2QsY0FBQSxJQUM1Q2U7QUFFWDtNQVpTTDtBQVlSUyxLQVpRVDtBQWNULElBQUksQ0FBQyxPQUFPSCxPQUFPLFdBQVEsS0FBSyxjQUFlLE9BQU9BLE9BQU8sV0FBUSxLQUFLLFlBQVlBLE9BQU8sV0FBUSxLQUFLLFNBQVUsT0FBT0EsT0FBTyxXQUFRLENBQUNhLFVBQVUsS0FBSyxhQUFhO0lBQ3JLN0IsT0FBT2UsY0FBYyxDQUFDQyxPQUFPLFdBQVEsRUFBRSxjQUFjO1FBQUVDLE9BQU87SUFBSztJQUNuRWpCLE9BQU84QixNQUFNLENBQUNkLE9BQU8sV0FBUSxFQUFFQTtJQUMvQmUsT0FBT2YsT0FBTyxHQUFHQSxPQUFPLFdBQVE7QUFDbEM7QUFBQyxJQUFBWTtBQUFBSSxhQUFBSixJQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXBhZ2UuanM/YzRkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRQYWdlUm9vdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQ2xpZW50UGFnZVJvb3Q7XG4gICAgfVxufSk7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9zZWFyY2hwYXJhbXMgPSByZXF1aXJlKFwiLi9zZWFyY2gtcGFyYW1zXCIpO1xuZnVuY3Rpb24gQ2xpZW50UGFnZVJvb3QocGFyYW0pIHtcbiAgICBsZXQgeyBDb21wb25lbnQsIHByb3BzIH0gPSBwYXJhbTtcbiAgICAvLyBXZSBleHBlY3QgdG8gYmUgcGFzc2VkIHNlYXJjaFBhcmFtcyBidXQgZXZlbiBpZiB3ZSBhcmVuJ3Qgd2UgY2FuIGNvbnN0cnVjdCBvbmUgZnJvbVxuICAgIC8vIGFuIGVtcHR5IG9iamVjdC4gV2Ugb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhIHN0YXRpYyBnZW5lcmF0aW9uIGFzIGEgcGVyZm9ybWFuY2VcbiAgICAvLyBvcHRpbWl6YXRpb24uIElkZWFsbHkgd2UnZCB1bmNvbmRpdGlvbmFsbHkgY29uc3RydWN0IHRoZSB0cmFja2VkIHBhcmFtcyBidXQgc2luY2VcbiAgICAvLyB0aGlzIGNyZWF0ZXMgYSBwcm94eSB3aGljaCBpcyBzbG93IGFuZCB0aGlzIHdvdWxkIGhhcHBlbiBldmVuIGZvciBjbGllbnQgbmF2aWdhdGlvbnNcbiAgICAvLyB0aGF0IGFyZSBkb25lIGVudGlyZWx5IGR5bmFtaWNhbGx5IGFuZCB3ZSBrbm93IHRoZXJlIHRoZSBkeW5hbWljIHRyYWNraW5nIGlzIGEgbm9vcFxuICAgIC8vIGluIHRoaXMgZHluYW1pYyBjYXNlIHdlIGNhbiBzYWZlbHkgZWxpZGUgaXQuXG4gICAgcHJvcHMuc2VhcmNoUGFyYW1zID0gKDAsIF9zZWFyY2hwYXJhbXMuY3JlYXRlRHluYW1pY2FsbHlUcmFja2VkU2VhcmNoUGFyYW1zKShwcm9wcy5zZWFyY2hQYXJhbXMgfHwge30pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKENvbXBvbmVudCwge1xuICAgICAgICAuLi5wcm9wc1xuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQtcGFnZS5qcy5tYXAiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5IiwicmVxdWlyZSIsIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXQiLCJDbGllbnRQYWdlUm9vdCIsIl9qc3hydW50aW1lIiwiX3NlYXJjaHBhcmFtcyIsInBhcmFtIiwiQ29tcG9uZW50IiwicHJvcHMiLCJzZWFyY2hQYXJhbXMiLCJjcmVhdGVEeW5hbWljYWxseVRyYWNrZWRTZWFyY2hQYXJhbXMiLCJqc3giLCJfYyIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiLCIkUmVmcmVzaFJlZyQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/hooks-server-context.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/hooks-server-context.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\nvar _inherits = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js\");\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js\");\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js\");\nvar _wrapNativeSuper = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/wrapNativeSuper.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/wrapNativeSuper.js\");\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DynamicServerError: function DynamicServerError() {\n        return _DynamicServerError;\n    },\n    isDynamicServerError: function isDynamicServerError() {\n        return _isDynamicServerError;\n    }\n});\nvar DYNAMIC_ERROR_CODE = \"DYNAMIC_SERVER_USAGE\";\nvar _DynamicServerError = /*#__PURE__*/ function(_Error) {\n    _inherits(_DynamicServerError, _Error);\n    var _super = _createSuper(_DynamicServerError);\n    function _DynamicServerError(description) {\n        var _this;\n        _classCallCheck(this, _DynamicServerError);\n        _this = _super.call(this, \"Dynamic server usage: \" + description);\n        _this.description = description;\n        _this.digest = DYNAMIC_ERROR_CODE;\n        return _this;\n    }\n    return _createClass(_DynamicServerError);\n}(/*#__PURE__*/ _wrapNativeSuper(Error));\nfunction _isDynamicServerError(err) {\n    if (typeof err !== \"object\" || err === null || !(\"digest\" in err) || typeof err.digest !== \"string\") {\n        return false;\n    }\n    return err.digest === DYNAMIC_ERROR_CODE;\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQSxJQUFBQSxlQUFBQyxtQkFBQUEsQ0FBQTtBQUFBLElBQUFDLGtCQUFBRCxtQkFBQUEsQ0FBQTtBQUFBLElBQUFFLFlBQUFGLG1CQUFBQSxDQUFBO0FBQUEsSUFBQUcsNkJBQUFILG1CQUFBQSxDQUFBO0FBQUEsSUFBQUksa0JBQUFKLG1CQUFBQSxDQUFBO0FBQUEsSUFBQUssbUJBQUFMLG1CQUFBQSxDQUFBO0FBQUEsU0FBQU0sYUFBQUMsT0FBQTtJQUFBLElBQUFDLDRCQUFBQztJQUFBLGdCQUFBQztRQUFBLElBQUFDLFFBQUFQLGdCQUFBRyxVQUFBSztRQUFBLElBQUFKLDJCQUFBO1lBQUEsSUFBQUssWUFBQVQsZ0JBQUEsTUFBQVUsV0FBQTtZQUFBRixTQUFBRyxRQUFBQyxTQUFBLENBQUFMLE9BQUFNLFdBQUFKO1FBQUE7WUFBQUQsU0FBQUQsTUFBQU8sS0FBQSxPQUFBRDtRQUFBO1FBQUEsT0FBQWQsMkJBQUEsTUFBQVM7SUFBQTtBQUFBO0FBQUEsU0FBQUg7SUFBQSxXQUFBTSxZQUFBLGdCQUFBQSxRQUFBQyxTQUFBO0lBQUEsSUFBQUQsUUFBQUMsU0FBQSxDQUFBRyxJQUFBO0lBQUEsV0FBQUMsVUFBQTtJQUFBO1FBQUFDLFFBQUFDLFNBQUEsQ0FBQUMsT0FBQSxDQUFBQyxJQUFBLENBQUFULFFBQUFDLFNBQUEsQ0FBQUssU0FBQTtRQUFBO0lBQUEsU0FBQUksR0FBQTtRQUFBO0lBQUE7QUFBQTtBQUNiQyw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSTtJQUNqQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsb0JBQW9CLFNBQUFBO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCLFNBQUFBO1FBQ2xCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLElBQU1PLHFCQUFxQjtBQUF1QixJQUM1Q1Isc0JBQWtCLHVCQUFBUyxNQUFBO0lBQUF0QyxVQUFBdUMscUJBQUFEO0lBQUEsSUFBQUUsU0FBQXBDLGFBQUFtQztJQUNwQixTQUFBQSxvQkFBWUUsV0FBVztRQUFDLElBQUFDO1FBQUEzQyxnQkFBQSxNQUFBd0M7UUFDcEJHLFFBQUFGLE9BQUFsQixJQUFBLE9BQU0sMkJBQTJCbUI7UUFDakNDLE1BQUtELFdBQVcsR0FBR0E7UUFDbkJDLE1BQUtDLE1BQU0sR0FBR047UUFBbUIsT0FBQUs7SUFDckM7SUFBQyxPQUFBN0MsYUFBQTBDO0FBQUEsZ0JBQUFwQyxpQkFMNEJ5QztBQU9qQyxTQUFTZCxzQkFBcUJlLEdBQUc7SUFDN0IsSUFBSSxPQUFPQSxRQUFRLFlBQVlBLFFBQVEsUUFBUSxDQUFFLGFBQVlBLEdBQUFBLEtBQVEsT0FBT0EsSUFBSUYsTUFBTSxLQUFLLFVBQVU7UUFDakcsT0FBTztJQUNYO0lBQ0EsT0FBT0UsSUFBSUYsTUFBTSxLQUFLTjtBQUMxQjtBQUVBLElBQUksQ0FBQyxPQUFPWCxPQUFPLFdBQVEsS0FBSyxjQUFlLE9BQU9BLE9BQU8sV0FBUSxLQUFLLFlBQVlBLE9BQU8sV0FBUSxLQUFLLFNBQVUsT0FBT0EsT0FBTyxXQUFRLENBQUNvQixVQUFVLEtBQUssYUFBYTtJQUNyS3RCLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBTyxXQUFRLEVBQUUsY0FBYztRQUFFQyxPQUFPO0lBQUs7SUFDbkVILE9BQU91QixNQUFNLENBQUNyQixPQUFPLFdBQVEsRUFBRUE7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsT0FBTyxXQUFRO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQuanM/MDA5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIER5bmFtaWNTZXJ2ZXJFcnJvcjogbnVsbCxcbiAgICBpc0R5bmFtaWNTZXJ2ZXJFcnJvcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBEeW5hbWljU2VydmVyRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRHluYW1pY1NlcnZlckVycm9yO1xuICAgIH0sXG4gICAgaXNEeW5hbWljU2VydmVyRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNEeW5hbWljU2VydmVyRXJyb3I7XG4gICAgfVxufSk7XG5jb25zdCBEWU5BTUlDX0VSUk9SX0NPREUgPSBcIkRZTkFNSUNfU0VSVkVSX1VTQUdFXCI7XG5jbGFzcyBEeW5hbWljU2VydmVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZGVzY3JpcHRpb24pe1xuICAgICAgICBzdXBlcihcIkR5bmFtaWMgc2VydmVyIHVzYWdlOiBcIiArIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmRpZ2VzdCA9IERZTkFNSUNfRVJST1JfQ09ERTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0R5bmFtaWNTZXJ2ZXJFcnJvcihlcnIpIHtcbiAgICBpZiAodHlwZW9mIGVyciAhPT0gXCJvYmplY3RcIiB8fCBlcnIgPT09IG51bGwgfHwgIShcImRpZ2VzdFwiIGluIGVycikgfHwgdHlwZW9mIGVyci5kaWdlc3QgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZXJyLmRpZ2VzdCA9PT0gRFlOQU1JQ19FUlJPUl9DT0RFO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy1zZXJ2ZXItY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiX2NyZWF0ZUNsYXNzIiwicmVxdWlyZSIsIl9jbGFzc0NhbGxDaGVjayIsIl9pbmhlcml0cyIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2dldFByb3RvdHlwZU9mIiwiX3dyYXBOYXRpdmVTdXBlciIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJyZXN1bHQiLCJOZXdUYXJnZXQiLCJjb25zdHJ1Y3RvciIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJhcmd1bWVudHMiLCJhcHBseSIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJwcm90b3R5cGUiLCJ2YWx1ZU9mIiwiY2FsbCIsImUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIkR5bmFtaWNTZXJ2ZXJFcnJvciIsImlzRHluYW1pY1NlcnZlckVycm9yIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiRFlOQU1JQ19FUlJPUl9DT0RFIiwiX0Vycm9yIiwiX0R5bmFtaWNTZXJ2ZXJFcnJvciIsIl9zdXBlciIsImRlc2NyaXB0aW9uIiwiX3RoaXMiLCJkaWdlc3QiLCJFcnJvciIsImVyciIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/hooks-server-context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _toConsumableArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js\");\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\nvar _assertThisInitialized = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/assertThisInitialized.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/assertThisInitialized.js\");\nvar _inherits = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js\");\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js\");\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js\");\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return OuterLayoutRouter;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nvar _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nvar _fetchserverresponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nvar _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unresolved-thenable.js\");\nvar _errorboundary = __webpack_require__(/*! ./error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nvar _matchsegments = __webpack_require__(/*! ./match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nvar _handlesmoothscroll = __webpack_require__(/*! ../../shared/lib/router/utils/handle-smooth-scroll */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nvar _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nvar _notfoundboundary = __webpack_require__(/*! ./not-found-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js\");\nvar _getsegmentvalue = __webpack_require__(/*! ./router-reducer/reducers/get-segment-value */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\");\nvar _createroutercachekey = __webpack_require__(/*! ./router-reducer/create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nvar _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./router-reducer/reducers/has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        var _segmentPathToWalk = _slicedToArray(segmentPathToWalk, 2), segment = _segmentPathToWalk[0], parallelRouteKey = _segmentPathToWalk[1];\n        var isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    var subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        _objectSpread(_objectSpread({}, treeToRecreate[1]), {}, _defineProperty({}, parallelRouteKey, [\n                            subTree[0],\n                            subTree[1],\n                            subTree[2],\n                            \"refetch\"\n                        ]))\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    _objectSpread(_objectSpread({}, treeToRecreate[1]), {}, _defineProperty({}, parallelRouteKey, walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])))\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (false) {}\n    // Only apply strict mode warning when not in production\n    if (true) {\n        var originalConsoleError = console.error;\n        try {\n            console.error = function() {\n                for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){\n                    messages[_key] = arguments[_key];\n                }\n                // Ignore strict mode warning for the findDomNode call below\n                if (!messages[0].includes(\"Warning: %s is deprecated in StrictMode.\")) {\n                    originalConsoleError.apply(void 0, messages);\n                }\n            };\n            return _reactdom[\"default\"].findDOMNode(instance);\n        } finally{\n            console.error = originalConsoleError;\n        }\n    }\n    return _reactdom[\"default\"].findDOMNode(instance);\n}\nvar rectProperties = [\n    \"bottom\",\n    \"height\",\n    \"left\",\n    \"right\",\n    \"top\",\n    \"width\",\n    \"x\",\n    \"y\"\n];\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */ function shouldSkipElement(element) {\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\n    // even though the actual page content is offscreen\n    if ([\n        \"sticky\",\n        \"fixed\"\n    ].includes(getComputedStyle(element).position)) {\n        if (true) {\n            console.warn(\"Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:\", element);\n        }\n        return true;\n    }\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n    // because `offsetParent` doesn't consider document/body\n    var rect = element.getBoundingClientRect();\n    return rectProperties.every(function(item) {\n        return rect[item] === 0;\n    });\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    var rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === \"top\") {\n        return document.body;\n    }\n    var _document_getElementById;\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0];\n}\nvar InnerScrollAndFocusHandler = /*#__PURE__*/ function(_react$default$Compon) {\n    _inherits(InnerScrollAndFocusHandler, _react$default$Compon);\n    var _super = _createSuper(InnerScrollAndFocusHandler);\n    function InnerScrollAndFocusHandler() {\n        var _this;\n        _classCallCheck(this, InnerScrollAndFocusHandler);\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        _this = _super.call.apply(_super, [\n            this\n        ].concat(args));\n        _this.handlePotentialScroll = function() {\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            var _this$props = _this.props, focusAndScrollRef = _this$props.focusAndScrollRef, segmentPath = _this$props.segmentPath;\n            if (focusAndScrollRef.apply) {\n                // segmentPaths is an array of segment paths that should be scrolled to\n                // if the current segment path is not in the array, the scroll is not applied\n                // unless the array is empty, in which case the scroll is always applied\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some(function(scrollRefSegmentPath) {\n                    return segmentPath.every(function(segment, index) {\n                        return (0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index]);\n                    });\n                })) {\n                    return;\n                }\n                var domNode = null;\n                var hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(_assertThisInitialized(_this));\n                }\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof Element)) {\n                    return;\n                }\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n                // If the element is skipped, try to select the next sibling and try again.\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n                    if (domNode.nextElementSibling === null) {\n                        return;\n                    }\n                    domNode = domNode.nextElementSibling;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                focusAndScrollRef.hashFragment = null;\n                focusAndScrollRef.segmentPaths = [];\n                (0, _handlesmoothscroll.handleSmoothScroll)(function() {\n                    // In case of hash scroll, we only need to scroll the element into view\n                    if (hashFragment) {\n                        domNode.scrollIntoView();\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    var htmlElement = document.documentElement;\n                    var viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true,\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\n                });\n                // Mutate after scrolling so that it can be read by `handleSmoothScroll`\n                focusAndScrollRef.onlyHashChange = false;\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n        return _this;\n    }\n    _createClass(InnerScrollAndFocusHandler, [\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this.handlePotentialScroll();\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n                if (this.props.focusAndScrollRef.apply) {\n                    this.handlePotentialScroll();\n                }\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                return this.props.children;\n            }\n        }\n    ]);\n    return InnerScrollAndFocusHandler;\n}(_react[\"default\"].Component);\nfunction ScrollAndFocusHandler(param) {\n    var segmentPath = param.segmentPath, children = param.children;\n    var context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {\n        segmentPath: segmentPath,\n        focusAndScrollRef: context.focusAndScrollRef,\n        children: children\n    });\n}\n_c1 = ScrollAndFocusHandler;\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */ _c = ScrollAndFocusHandler;\nfunction InnerLayoutRouter(param) {\n    var parallelRouterKey = param.parallelRouterKey, url = param.url, childNodes = param.childNodes, segmentPath = param.segmentPath, tree = param.tree, cacheKey = param.cacheKey;\n    var context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    var buildId = context.buildId, changeByServerResponse = context.changeByServerResponse, fullTree = context.tree;\n    // Read segment path from the parallel router cache node.\n    var childNode = childNodes.get(cacheKey);\n    // When data is not available during rendering client-side we need to fetch\n    // it from the server.\n    if (childNode === undefined) {\n        var newLazyCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(),\n            lazyDataResolved: false,\n            loading: null\n        };\n        /**\n    * Flight data fetch kicked off during render and put into the cache.\n    */ childNode = newLazyCacheNode;\n        childNodes.set(cacheKey, newLazyCacheNode);\n    }\n    // `rsc` represents the renderable node for this segment.\n    // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n    // We should use that on initial render instead of `rsc`. Then we'll switch\n    // to `rsc` when the dynamic response streams in.\n    //\n    // If no prefetch data is available, then we go straight to rendering `rsc`.\n    var resolvedPrefetchRsc = childNode.prefetchRsc !== null ? childNode.prefetchRsc : childNode.rsc;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    //\n    // @ts-expect-error The second argument to `useDeferredValue` is only\n    // available in the experimental builds. When its disabled, it will always\n    // return `rsc`.\n    var rsc = (0, _react.useDeferredValue)(childNode.rsc, resolvedPrefetchRsc);\n    // `rsc` is either a React node or a promise for a React node, except we\n    // special case `null` to represent that this segment's data is missing. If\n    // it's a promise, we need to unwrap it so we can determine whether or not the\n    // data is missing.\n    var resolvedRsc = typeof rsc === \"object\" && rsc !== null && typeof rsc.then === \"function\" ? (0, _react.use)(rsc) : rsc;\n    if (!resolvedRsc) {\n        // The data for this segment is not available, and there's no pending\n        // navigation that will be able to fulfill it. We need to fetch more from\n        // the server and patch the cache.\n        // Check if there's already a pending request.\n        var lazyData = childNode.lazyData;\n        if (lazyData === null) {\n            /**\n      * Router state with refetch marker added\n      */ // TODO-APP: remove ''\n            var refetchTree = walkAddRefetch([\n                \"\"\n            ].concat(_toConsumableArray(segmentPath)), fullTree);\n            var includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(fullTree);\n            childNode.lazyData = lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), refetchTree, includeNextUrl ? context.nextUrl : null, buildId);\n            childNode.lazyDataResolved = false;\n        }\n        /**\n    * Flight response data\n    */ // When the data has not resolved yet `use` will suspend here.\n        var serverResponse = (0, _react.use)(lazyData);\n        if (!childNode.lazyDataResolved) {\n            // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n            setTimeout(function() {\n                (0, _react.startTransition)(function() {\n                    changeByServerResponse({\n                        previousTree: fullTree,\n                        serverResponse: serverResponse\n                    });\n                });\n            });\n            // It's important that we mark this as resolved, in case this branch is replayed, we don't want to continously re-apply\n            // the patch to the tree.\n            childNode.lazyDataResolved = true;\n        }\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n        (0, _react.use)(_unresolvedthenable.unresolvedThenable);\n    }\n    // If we get to this point, then we know we have something we can render.\n    var subtree = // The layout router context narrows down tree and childNodes at each level.\n    /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url,\n            loading: childNode.loading\n        },\n        children: resolvedRsc\n    });\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return subtree;\n}\n_c5 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ _c2 = InnerLayoutRouter;\nfunction LoadingBoundary(param) {\n    var children = param.children, hasLoading = param.hasLoading, loading = param.loading, loadingStyles = param.loadingStyles, loadingScripts = param.loadingScripts;\n    // We have an explicit prop for checking if `loading` is provided, to disambiguate between a loading\n    // component that returns `null` / `undefined`, vs not having a loading component at all.\n    if (hasLoading) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {\n            fallback: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    loadingStyles,\n                    loadingScripts,\n                    loading\n                ]\n            }),\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c6 = LoadingBoundary;\n_c3 = LoadingBoundary;\nfunction OuterLayoutRouter(param) {\n    var parallelRouterKey = param.parallelRouterKey, segmentPath = param.segmentPath, error = param.error, errorStyles = param.errorStyles, errorScripts = param.errorScripts, templateStyles = param.templateStyles, templateScripts = param.templateScripts, template = param.template, notFound = param.notFound, notFoundStyles = param.notFoundStyles;\n    var context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    var childNodes = context.childNodes, tree = context.tree, url = context.url, loading = context.loading;\n    // Get the current parallelRouter cache node\n    var childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodesForParallelRouter = new Map();\n        childNodes.set(parallelRouterKey, childNodesForParallelRouter);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    var treeSegment = tree[1][parallelRouterKey][0];\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    var currentChildSegmentValue = (0, _getsegmentvalue.getSegmentValue)(treeSegment);\n    /**\n  * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n  */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    var preservedSegments = [\n        treeSegment\n    ];\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: preservedSegments.map(function(preservedSegment) {\n            var preservedSegmentValue = (0, _getsegmentvalue.getSegmentValue)(preservedSegment);\n            var cacheKey = (0, _createroutercachekey.createRouterCacheKey)(preservedSegment);\n            return(/*\n        - Error boundary\n        - Only renders error boundary if error component is provided.\n        - Rendered for each segment to ensure they have their own error state.\n        - Loading boundary\n        - Only renders suspense boundary if loading components is provided.\n        - Rendered for each segment to ensure they have their own loading state.\n        - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n        */ /*#__PURE__*/ (0, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {\n                value: /*#__PURE__*/ (0, _jsxruntime.jsx)(ScrollAndFocusHandler, {\n                    segmentPath: segmentPath,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n                        errorComponent: error,\n                        errorStyles: errorStyles,\n                        errorScripts: errorScripts,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingBoundary, {\n                            hasLoading: Boolean(loading),\n                            loading: loading == null ? void 0 : loading[0],\n                            loadingStyles: loading == null ? void 0 : loading[1],\n                            loadingScripts: loading == null ? void 0 : loading[2],\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_notfoundboundary.NotFoundBoundary, {\n                                notFound: notFound,\n                                notFoundStyles: notFoundStyles,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_redirectboundary.RedirectBoundary, {\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerLayoutRouter, {\n                                        parallelRouterKey: parallelRouterKey,\n                                        url: url,\n                                        tree: tree,\n                                        childNodes: childNodesForParallelRouter,\n                                        segmentPath: segmentPath,\n                                        cacheKey: cacheKey,\n                                        isActive: currentChildSegmentValue === preservedSegmentValue\n                                    })\n                                })\n                            })\n                        })\n                    })\n                }),\n                children: [\n                    templateStyles,\n                    templateScripts,\n                    template\n                ]\n            }, (0, _createroutercachekey.createRouterCacheKey)(preservedSegment, true)));\n        })\n    });\n}\n_c7 = OuterLayoutRouter;\n_c4 = OuterLayoutRouter;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n}\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ScrollAndFocusHandler\");\n$RefreshReg$(_c2, \"InnerLayoutRouter\");\n$RefreshReg$(_c3, \"LoadingBoundary\");\n$RefreshReg$(_c4, \"OuterLayoutRouter\");\nvar _c1, _c5, _c6, _c7;\n$RefreshReg$(_c1, \"ScrollAndFocusHandler\");\n$RefreshReg$(_c5, \"InnerLayoutRouter\");\n$RefreshReg$(_c6, \"LoadingBoundary\");\n$RefreshReg$(_c7, \"OuterLayoutRouter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFBQSxJQUFBQSxxQkFBQUMsbUJBQUFBLENBQUE7QUFBQSxJQUFBQyxrQkFBQUQsbUJBQUFBLENBQUE7QUFBQSxJQUFBRSxlQUFBRixtQkFBQUEsQ0FBQTtBQUFBLElBQUFHLHlCQUFBSCxtQkFBQUEsQ0FBQTtBQUFBLElBQUFJLFlBQUFKLG1CQUFBQSxDQUFBO0FBQUEsSUFBQUssNkJBQUFMLG1CQUFBQSxDQUFBO0FBQUEsSUFBQU0sa0JBQUFOLG1CQUFBQSxDQUFBO0FBQUEsSUFBQU8sa0JBQUFQLG1CQUFBQSxDQUFBO0FBQUEsSUFBQVEsaUJBQUFSLG1CQUFBQSxDQUFBO0FBQUEsU0FBQVMsYUFBQUMsT0FBQTtJQUFBLElBQUFDLDRCQUFBQztJQUFBLGdCQUFBQztRQUFBLElBQUFDLFFBQUFSLGdCQUFBSSxVQUFBSztRQUFBLElBQUFKLDJCQUFBO1lBQUEsSUFBQUssWUFBQVYsZ0JBQUEsTUFBQVcsV0FBQTtZQUFBRixTQUFBRyxRQUFBQyxTQUFBLENBQUFMLE9BQUFNLFdBQUFKO1FBQUE7WUFBQUQsU0FBQUQsTUFBQU8sS0FBQSxPQUFBRDtRQUFBO1FBQUEsT0FBQWYsMkJBQUEsTUFBQVU7SUFBQTtBQUFBO0FBQUEsU0FBQUg7SUFBQSxXQUFBTSxZQUFBLGdCQUFBQSxRQUFBQyxTQUFBO0lBQUEsSUFBQUQsUUFBQUMsU0FBQSxDQUFBRyxJQUFBO0lBQUEsV0FBQUMsVUFBQTtJQUFBO1FBQUFDLFFBQUFDLFNBQUEsQ0FBQUMsT0FBQSxDQUFBQyxJQUFBLENBQUFULFFBQUFDLFNBQUEsQ0FBQUssU0FBQTtRQUFBO0lBQUEsU0FBQUksR0FBQTtRQUFBO0lBQUE7QUFBQTtBQUFBLFNBQUFDLFFBQUFELENBQUEsRUFBQUUsQ0FBQTtJQUFBLElBQUFDLElBQUFDLE9BQUFDLElBQUEsQ0FB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O0FBQUErRSxhQUFBcEMsS0FBQTtBQUFBb0MsYUFBQTNCLEtBQUE7QUFBQTJCLGFBQUFKLEtBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzPzBiZmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIC8qKlxuICogT3V0ZXJMYXlvdXRSb3V0ZXIgaGFuZGxlcyB0aGUgY3VycmVudCBzZWdtZW50IGFzIHdlbGwgYXMgPE9mZnNjcmVlbj4gcmVuZGVyaW5nIG9mIG90aGVyIHNlZ21lbnRzLlxuICogSXQgY2FuIGJlIHJlbmRlcmVkIG5leHQgdG8gZWFjaCBvdGhlciB3aXRoIGEgZGlmZmVyZW50IGBwYXJhbGxlbFJvdXRlcktleWAsIGFsbG93aW5nIGZvciBQYXJhbGxlbCByb3V0ZXMuXG4gKi8gXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPdXRlckxheW91dFJvdXRlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfcmVhY3Rkb20gPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuY29uc3QgX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2ZldGNoc2VydmVycmVzcG9uc2UgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2VcIik7XG5jb25zdCBfdW5yZXNvbHZlZHRoZW5hYmxlID0gcmVxdWlyZShcIi4vdW5yZXNvbHZlZC10aGVuYWJsZVwiKTtcbmNvbnN0IF9lcnJvcmJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vZXJyb3ItYm91bmRhcnlcIik7XG5jb25zdCBfbWF0Y2hzZWdtZW50cyA9IHJlcXVpcmUoXCIuL21hdGNoLXNlZ21lbnRzXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmNvbnN0IF9yZWRpcmVjdGJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vcmVkaXJlY3QtYm91bmRhcnlcIik7XG5jb25zdCBfbm90Zm91bmRib3VuZGFyeSA9IHJlcXVpcmUoXCIuL25vdC1mb3VuZC1ib3VuZGFyeVwiKTtcbmNvbnN0IF9nZXRzZWdtZW50dmFsdWUgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZVwiKTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5XCIpO1xuY29uc3QgX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlXCIpO1xuLyoqXG4gKiBBZGQgcmVmZXRjaCBtYXJrZXIgdG8gcm91dGVyIHN0YXRlIGF0IHRoZSBwb2ludCBvZiB0aGUgY3VycmVudCBsYXlvdXQgc2VnbWVudC5cbiAqIFRoaXMgZW5zdXJlcyB0aGUgcmVzcG9uc2UgcmV0dXJuZWQgaXMgbm90IGZ1cnRoZXIgZG93biB0aGFuIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICovIGZ1bmN0aW9uIHdhbGtBZGRSZWZldGNoKHNlZ21lbnRQYXRoVG9XYWxrLCB0cmVlVG9SZWNyZWF0ZSkge1xuICAgIGlmIChzZWdtZW50UGF0aFRvV2Fsaykge1xuICAgICAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBzZWdtZW50UGF0aFRvV2FsaztcbiAgICAgICAgY29uc3QgaXNMYXN0ID0gc2VnbWVudFBhdGhUb1dhbGsubGVuZ3RoID09PSAyO1xuICAgICAgICBpZiAoKDAsIF9tYXRjaHNlZ21lbnRzLm1hdGNoU2VnbWVudCkodHJlZVRvUmVjcmVhdGVbMF0sIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICBpZiAodHJlZVRvUmVjcmVhdGVbMV0uaGFzT3duUHJvcGVydHkocGFyYWxsZWxSb3V0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSB3YWxrQWRkUmVmZXRjaCh1bmRlZmluZWQsIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRyZWVUb1JlY3JlYXRlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlZmV0Y2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMF0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRyZWVUb1JlY3JlYXRlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiB3YWxrQWRkUmVmZXRjaChzZWdtZW50UGF0aFRvV2Fsay5zbGljZSgyKSwgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmVlVG9SZWNyZWF0ZTtcbn1cbi8vIFRPRE8tQVBQOiBSZXBsYWNlIHdpdGggbmV3IFJlYWN0IEFQSSBmb3IgZmluZGluZyBkb20gbm9kZXMgd2l0aG91dCBhIGByZWZgIHdoZW4gYXZhaWxhYmxlXG4vKipcbiAqIFdyYXBzIFJlYWN0RE9NLmZpbmRET01Ob2RlIHdpdGggYWRkaXRpb25hbCBsb2dpYyB0byBoaWRlIFJlYWN0IFN0cmljdCBNb2RlIHdhcm5pbmdcbiAqLyBmdW5jdGlvbiBmaW5kRE9NTm9kZShpbnN0YW5jZSkge1xuICAgIC8vIFRyZWUtc2hha2UgZm9yIHNlcnZlciBidW5kbGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGw7XG4gICAgLy8gT25seSBhcHBseSBzdHJpY3QgbW9kZSB3YXJuaW5nIHdoZW4gbm90IGluIHByb2R1Y3Rpb25cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ29uc29sZUVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtZXNzYWdlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHN0cmljdCBtb2RlIHdhcm5pbmcgZm9yIHRoZSBmaW5kRG9tTm9kZSBjYWxsIGJlbG93XG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlc1swXS5pbmNsdWRlcyhcIldhcm5pbmc6ICVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDb25zb2xlRXJyb3IoLi4ubWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gX3JlYWN0ZG9tLmRlZmF1bHQuZmluZERPTU5vZGUoaW5zdGFuY2UpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yID0gb3JpZ2luYWxDb25zb2xlRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdGRvbS5kZWZhdWx0LmZpbmRET01Ob2RlKGluc3RhbmNlKTtcbn1cbmNvbnN0IHJlY3RQcm9wZXJ0aWVzID0gW1xuICAgIFwiYm90dG9tXCIsXG4gICAgXCJoZWlnaHRcIixcbiAgICBcImxlZnRcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJ0b3BcIixcbiAgICBcIndpZHRoXCIsXG4gICAgXCJ4XCIsXG4gICAgXCJ5XCJcbl07XG4vKipcbiAqIENoZWNrIGlmIGEgSFRNTEVsZW1lbnQgaXMgaGlkZGVuIG9yIGZpeGVkL3N0aWNreSBwb3NpdGlvblxuICovIGZ1bmN0aW9uIHNob3VsZFNraXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAvLyB3ZSBpZ25vcmUgZml4ZWQgb3Igc3RpY2t5IHBvc2l0aW9uZWQgZWxlbWVudHMgc2luY2UgdGhleSdsbCBsaWtlbHkgcGFzcyB0aGUgXCJpbi12aWV3cG9ydFwiIGNoZWNrXG4gICAgLy8gYW5kIHdpbGwgcmVzdWx0IGluIGEgc2l0dWF0aW9uIHdlIGJhaWwgb24gc2Nyb2xsIGJlY2F1c2Ugb2Ygc29tZXRoaW5nIGxpa2UgYSBmaXhlZCBuYXYsXG4gICAgLy8gZXZlbiB0aG91Z2ggdGhlIGFjdHVhbCBwYWdlIGNvbnRlbnQgaXMgb2Zmc2NyZWVuXG4gICAgaWYgKFtcbiAgICAgICAgXCJzdGlja3lcIixcbiAgICAgICAgXCJmaXhlZFwiXG4gICAgXS5pbmNsdWRlcyhnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU2tpcHBpbmcgYXV0by1zY3JvbGwgYmVoYXZpb3IgZHVlIHRvIGBwb3NpdGlvbjogc3RpY2t5YCBvciBgcG9zaXRpb246IGZpeGVkYCBvbiBlbGVtZW50OlwiLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVXNlcyBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCB0byBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyBoaWRkZW4gaW5zdGVhZCBvZiBgb2Zmc2V0UGFyZW50YFxuICAgIC8vIGJlY2F1c2UgYG9mZnNldFBhcmVudGAgZG9lc24ndCBjb25zaWRlciBkb2N1bWVudC9ib2R5XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3RQcm9wZXJ0aWVzLmV2ZXJ5KChpdGVtKT0+cmVjdFtpdGVtXSA9PT0gMCk7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSB0b3AgY29ybmVyIG9mIHRoZSBIVE1MRWxlbWVudCBpcyBpbiB0aGUgdmlld3BvcnQuXG4gKi8gZnVuY3Rpb24gdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50LCB2aWV3cG9ydEhlaWdodCkge1xuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiByZWN0LnRvcCA+PSAwICYmIHJlY3QudG9wIDw9IHZpZXdwb3J0SGVpZ2h0O1xufVxuLyoqXG4gKiBGaW5kIHRoZSBET00gbm9kZSBmb3IgYSBoYXNoIGZyYWdtZW50LlxuICogSWYgYHRvcGAgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLiBUaGlzIG1pcnJvcnMgdGhlIGJyb3dzZXIncyBiZWhhdmlvci5cbiAqIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGFuIGlkLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBlbGVtZW50IHdpdGggdGhhdCBpZC5cbiAqIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGEgbmFtZSwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHRoYXQgbmFtZS5cbiAqLyBmdW5jdGlvbiBnZXRIYXNoRnJhZ21lbnREb21Ob2RlKGhhc2hGcmFnbWVudCkge1xuICAgIC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGB0b3BgIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5cbiAgICBpZiAoaGFzaEZyYWdtZW50ID09PSBcInRvcFwiKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgIH1cbiAgICB2YXIgX2RvY3VtZW50X2dldEVsZW1lbnRCeUlkO1xuICAgIC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGFuIGlkLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBlbGVtZW50IHdpdGggdGhhdCBpZC5cbiAgICByZXR1cm4gKF9kb2N1bWVudF9nZXRFbGVtZW50QnlJZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2hGcmFnbWVudCkpICE9IG51bGwgPyBfZG9jdW1lbnRfZ2V0RWxlbWVudEJ5SWQgOiAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhIG5hbWUsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGF0IG5hbWUuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaEZyYWdtZW50KVswXTtcbn1cbmNsYXNzIElubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBCZWNhdXNlIHRoaXMgcHJvcGVydHkgaXMgb3ZlcndyaXR0ZW4gaW4gaGFuZGxlUG90ZW50aWFsU2Nyb2xsIGl0J3MgZmluZSB0byBhbHdheXMgcnVuIGl0IHdoZW4gdHJ1ZSBhcyBpdCdsbCBiZSBzZXQgdG8gZmFsc2UgZm9yIHN1YnNlcXVlbnQgcmVuZGVycy5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG90ZW50aWFsU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVBvdGVudGlhbFNjcm9sbCA9ICgpPT57XG4gICAgICAgICAgICAvLyBIYW5kbGUgc2Nyb2xsIGFuZCBmb2N1cywgaXQncyBvbmx5IGFwcGxpZWQgb25jZSBpbiB0aGUgZmlyc3QgdXNlRWZmZWN0IHRoYXQgdHJpZ2dlcnMgdGhhdCBjaGFuZ2VkLlxuICAgICAgICAgICAgY29uc3QgeyBmb2N1c0FuZFNjcm9sbFJlZiwgc2VnbWVudFBhdGggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50UGF0aHMgaXMgYW4gYXJyYXkgb2Ygc2VnbWVudCBwYXRocyB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCB0b1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHNlZ21lbnQgcGF0aCBpcyBub3QgaW4gdGhlIGFycmF5LCB0aGUgc2Nyb2xsIGlzIG5vdCBhcHBsaWVkXG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIHRoZSBhcnJheSBpcyBlbXB0eSwgaW4gd2hpY2ggY2FzZSB0aGUgc2Nyb2xsIGlzIGFsd2F5cyBhcHBsaWVkXG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocy5sZW5ndGggIT09IDAgJiYgIWZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocy5zb21lKChzY3JvbGxSZWZTZWdtZW50UGF0aCk9PnNlZ21lbnRQYXRoLmV2ZXJ5KChzZWdtZW50LCBpbmRleCk9PigwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKHNlZ21lbnQsIHNjcm9sbFJlZlNlZ21lbnRQYXRoW2luZGV4XSkpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkb21Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoRnJhZ21lbnQgPSBmb2N1c0FuZFNjcm9sbFJlZi5oYXNoRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGhhc2hGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlID0gZ2V0SGFzaEZyYWdtZW50RG9tTm9kZShoYXNoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgZmluZERPTU5vZGVgIGlzIHRyaWNreSBiZWNhdXNlIGl0IHJldHVybnMganVzdCB0aGUgZmlyc3QgY2hpbGQgaWYgdGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxyZWFkeSBjYXVzZWQgYSBidWcgd2hlcmUgdGhlIGZpcnN0IGNoaWxkIHdhcyBhIDxsaW5rLz4gaW4gaGVhZC5cbiAgICAgICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBET00gbm9kZSB0aGlzIGxheW91dC1yb3V0ZXIgbGV2ZWwgaXMgc2tpcHBlZC4gSXQnbGwgYmUgaGFuZGxlZCBoaWdoZXItdXAgaW4gdGhlIHRyZWUuXG4gICAgICAgICAgICAgICAgaWYgKCEoZG9tTm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IGlmIHRoZSBlbGVtZW50IGlzIGEgSFRNTEVsZW1lbnQgYW5kIGlmIHdlIHdhbnQgdG8gY29uc2lkZXIgaXQgZm9yIHNjcm9sbCBiZWhhdmlvci5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBza2lwcGVkLCB0cnkgdG8gc2VsZWN0IHRoZSBuZXh0IHNpYmxpbmcgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICB3aGlsZSghKGRvbU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgfHwgc2hvdWxkU2tpcEVsZW1lbnQoZG9tTm9kZSkpe1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBzaWJsaW5ncyBmb3VuZCB0aGF0IG1hdGNoIHRoZSBjcml0ZXJpYSBhcmUgZm91bmQsIHNvIGhhbmRsZSBzY3JvbGwgaGlnaGVyIHVwIGluIHRoZSB0cmVlIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Ob2RlLm5leHRFbGVtZW50U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUgPSBkb21Ob2RlLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RhdGUgaXMgbXV0YXRlZCB0byBlbnN1cmUgdGhhdCB0aGUgZm9jdXMgYW5kIHNjcm9sbCBpcyBhcHBsaWVkIG9ubHkgb25jZS5cbiAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZi5hcHBseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmhhc2hGcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuc2VnbWVudFBhdGhzID0gW107XG4gICAgICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGhhc2ggc2Nyb2xsLCB3ZSBvbmx5IG5lZWQgdG8gc2Nyb2xsIHRoZSBlbGVtZW50IGludG8gdmlld1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgaGVpZ2h0IGJlY2F1c2UgcmVhZGluZyBgY2xpZW50SGVpZ2h0YCBjYXVzZXMgYSByZWZsb3csXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpdCB3b24ndCBjaGFuZ2UgZHVyaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IGh0bWxFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQncyB0b3AgZWRnZSBpcyBhbHJlYWR5IGluIHRoZSB2aWV3cG9ydCwgZXhpdCBlYXJseS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0cnkgc2Nyb2xsaW5nIGdvIHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgd2l0aCBwYWdlc1xuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxJbnRvVmlldygpIGNhbGxlZCBvbiBgPGh0bWwvPmAgZWxlbWVudCBzY3JvbGxzIGhvcml6b250YWxseSBvbiBjaHJvbWUgYW5kIGZpcmVmb3ggKHRoYXQgc2hvdWxkbid0IGhhcHBlbilcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY291bGQgdXNlIGl0IHRvIHNjcm9sbCBob3Jpem9udGFsbHkgZm9sbG93aW5nIFJUTCBidXQgdGhhdCBhbHNvIHNlZW1zIHRvIGJlIGJyb2tlbiAtIGl0IHdpbGwgYWx3YXlzIHNjcm9sbCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIC8vIHNjcm9sbExlZnQgPSAwIGFsc28gc2VlbXMgdG8gaWdub3JlIFJUTCBhbmQgbWFudWFsbHkgY2hlY2tpbmcgZm9yIFJUTCBpcyB0b28gbXVjaCBoYXNzbGUgc28gd2Ugd2lsbCBzY3JvbGwganVzdCB2ZXJ0aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjcm9sbCB0byBkb21Ob2RlIGlmIGRvbU5vZGUgaXMgbm90IGluIHZpZXdwb3J0IHdoZW4gc2Nyb2xsZWQgdG8gdG9wIG9mIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICghdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChkb21Ob2RlLCB2aWV3cG9ydEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBmb3JjZSBsYXlvdXQgYnkgcXVlcnlpbmcgZG9tTm9kZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBkb250Rm9yY2VMYXlvdXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlIYXNoQ2hhbmdlOiBmb2N1c0FuZFNjcm9sbFJlZi5vbmx5SGFzaENoYW5nZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE11dGF0ZSBhZnRlciBzY3JvbGxpbmcgc28gdGhhdCBpdCBjYW4gYmUgcmVhZCBieSBgaGFuZGxlU21vb3RoU2Nyb2xsYFxuICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLm9ubHlIYXNoQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIFNjcm9sbEFuZEZvY3VzSGFuZGxlcihwYXJhbSkge1xuICAgIGxldCB7IHNlZ21lbnRQYXRoLCBjaGlsZHJlbiB9ID0gcGFyYW07XG4gICAgY29uc3QgY29udGV4dCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkdsb2JhbExheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKElubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyLCB7XG4gICAgICAgIHNlZ21lbnRQYXRoOiBzZWdtZW50UGF0aCxcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IGNvbnRleHQuZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xufVxuLyoqXG4gKiBJbm5lckxheW91dFJvdXRlciBoYW5kbGVzIHJlbmRlcmluZyB0aGUgcHJvdmlkZWQgc2VnbWVudCBiYXNlZCBvbiB0aGUgY2FjaGUuXG4gKi8gZnVuY3Rpb24gSW5uZXJMYXlvdXRSb3V0ZXIocGFyYW0pIHtcbiAgICBsZXQgeyBwYXJhbGxlbFJvdXRlcktleSwgdXJsLCBjaGlsZE5vZGVzLCBzZWdtZW50UGF0aCwgdHJlZSwgLy8gVE9ETy1BUFA6IGltcGxlbWVudCBgPE9mZnNjcmVlbj5gIHdoZW4gYXZhaWxhYmxlLlxuICAgIC8vIGlzQWN0aXZlLFxuICAgIGNhY2hlS2V5IH0gPSBwYXJhbTtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFyaWFudCBnbG9iYWwgbGF5b3V0IHJvdXRlciBub3QgbW91bnRlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBidWlsZElkLCBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlLCB0cmVlOiBmdWxsVHJlZSB9ID0gY29udGV4dDtcbiAgICAvLyBSZWFkIHNlZ21lbnQgcGF0aCBmcm9tIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZS5cbiAgICBsZXQgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQoY2FjaGVLZXkpO1xuICAgIC8vIFdoZW4gZGF0YSBpcyBub3QgYXZhaWxhYmxlIGR1cmluZyByZW5kZXJpbmcgY2xpZW50LXNpZGUgd2UgbmVlZCB0byBmZXRjaFxuICAgIC8vIGl0IGZyb20gdGhlIHNlcnZlci5cbiAgICBpZiAoY2hpbGROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmV3TGF6eUNhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGxhenlEYXRhUmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbG9hZGluZzogbnVsbFxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgZGF0YSBmZXRjaCBraWNrZWQgb2ZmIGR1cmluZyByZW5kZXIgYW5kIHB1dCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKi8gY2hpbGROb2RlID0gbmV3TGF6eUNhY2hlTm9kZTtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQoY2FjaGVLZXksIG5ld0xhenlDYWNoZU5vZGUpO1xuICAgIH1cbiAgICAvLyBgcnNjYCByZXByZXNlbnRzIHRoZSByZW5kZXJhYmxlIG5vZGUgZm9yIHRoaXMgc2VnbWVudC5cbiAgICAvLyBJZiB0aGlzIHNlZ21lbnQgaGFzIGEgYHByZWZldGNoUnNjYCwgaXQncyB0aGUgc3RhdGljYWxseSBwcmVmZXRjaGVkIGRhdGEuXG4gICAgLy8gV2Ugc2hvdWxkIHVzZSB0aGF0IG9uIGluaXRpYWwgcmVuZGVyIGluc3RlYWQgb2YgYHJzY2AuIFRoZW4gd2UnbGwgc3dpdGNoXG4gICAgLy8gdG8gYHJzY2Agd2hlbiB0aGUgZHluYW1pYyByZXNwb25zZSBzdHJlYW1zIGluLlxuICAgIC8vXG4gICAgLy8gSWYgbm8gcHJlZmV0Y2ggZGF0YSBpcyBhdmFpbGFibGUsIHRoZW4gd2UgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIGByc2NgLlxuICAgIGNvbnN0IHJlc29sdmVkUHJlZmV0Y2hSc2MgPSBjaGlsZE5vZGUucHJlZmV0Y2hSc2MgIT09IG51bGwgPyBjaGlsZE5vZGUucHJlZmV0Y2hSc2MgOiBjaGlsZE5vZGUucnNjO1xuICAgIC8vIFdlIHVzZSBgdXNlRGVmZXJyZWRWYWx1ZWAgdG8gaGFuZGxlIHN3aXRjaGluZyBiZXR3ZWVuIHRoZSBwcmVmZXRjaGVkIGFuZFxuICAgIC8vIGZpbmFsIHZhbHVlcy4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyByZXR1cm5lZCBvbiBpbml0aWFsIHJlbmRlciwgdGhlbiBpdFxuICAgIC8vIHJlLXJlbmRlcnMgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgLy9cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYHVzZURlZmVycmVkVmFsdWVgIGlzIG9ubHlcbiAgICAvLyBhdmFpbGFibGUgaW4gdGhlIGV4cGVyaW1lbnRhbCBidWlsZHMuIFdoZW4gaXRzIGRpc2FibGVkLCBpdCB3aWxsIGFsd2F5c1xuICAgIC8vIHJldHVybiBgcnNjYC5cbiAgICBjb25zdCByc2MgPSAoMCwgX3JlYWN0LnVzZURlZmVycmVkVmFsdWUpKGNoaWxkTm9kZS5yc2MsIHJlc29sdmVkUHJlZmV0Y2hSc2MpO1xuICAgIC8vIGByc2NgIGlzIGVpdGhlciBhIFJlYWN0IG5vZGUgb3IgYSBwcm9taXNlIGZvciBhIFJlYWN0IG5vZGUsIGV4Y2VwdCB3ZVxuICAgIC8vIHNwZWNpYWwgY2FzZSBgbnVsbGAgdG8gcmVwcmVzZW50IHRoYXQgdGhpcyBzZWdtZW50J3MgZGF0YSBpcyBtaXNzaW5nLiBJZlxuICAgIC8vIGl0J3MgYSBwcm9taXNlLCB3ZSBuZWVkIHRvIHVud3JhcCBpdCBzbyB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZVxuICAgIC8vIGRhdGEgaXMgbWlzc2luZy5cbiAgICBjb25zdCByZXNvbHZlZFJzYyA9IHR5cGVvZiByc2MgPT09IFwib2JqZWN0XCIgJiYgcnNjICE9PSBudWxsICYmIHR5cGVvZiByc2MudGhlbiA9PT0gXCJmdW5jdGlvblwiID8gKDAsIF9yZWFjdC51c2UpKHJzYykgOiByc2M7XG4gICAgaWYgKCFyZXNvbHZlZFJzYykge1xuICAgICAgICAvLyBUaGUgZGF0YSBmb3IgdGhpcyBzZWdtZW50IGlzIG5vdCBhdmFpbGFibGUsIGFuZCB0aGVyZSdzIG5vIHBlbmRpbmdcbiAgICAgICAgLy8gbmF2aWdhdGlvbiB0aGF0IHdpbGwgYmUgYWJsZSB0byBmdWxmaWxsIGl0LiBXZSBuZWVkIHRvIGZldGNoIG1vcmUgZnJvbVxuICAgICAgICAvLyB0aGUgc2VydmVyIGFuZCBwYXRjaCB0aGUgY2FjaGUuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYWxyZWFkeSBhIHBlbmRpbmcgcmVxdWVzdC5cbiAgICAgICAgbGV0IGxhenlEYXRhID0gY2hpbGROb2RlLmxhenlEYXRhO1xuICAgICAgICBpZiAobGF6eURhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICogUm91dGVyIHN0YXRlIHdpdGggcmVmZXRjaCBtYXJrZXIgYWRkZWRcbiAgICAgICAqLyAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBjb25zdCByZWZldGNoVHJlZSA9IHdhbGtBZGRSZWZldGNoKFtcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgIC4uLnNlZ21lbnRQYXRoXG4gICAgICAgICAgICBdLCBmdWxsVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlTmV4dFVybCA9ICgwLCBfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlLmhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSkoZnVsbFRyZWUpO1xuICAgICAgICAgICAgY2hpbGROb2RlLmxhenlEYXRhID0gbGF6eURhdGEgPSAoMCwgX2ZldGNoc2VydmVycmVzcG9uc2UuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkobmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbiksIHJlZmV0Y2hUcmVlLCBpbmNsdWRlTmV4dFVybCA/IGNvbnRleHQubmV4dFVybCA6IG51bGwsIGJ1aWxkSWQpO1xuICAgICAgICAgICAgY2hpbGROb2RlLmxhenlEYXRhUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgcmVzcG9uc2UgZGF0YVxuICAgICAqLyAvLyBXaGVuIHRoZSBkYXRhIGhhcyBub3QgcmVzb2x2ZWQgeWV0IGB1c2VgIHdpbGwgc3VzcGVuZCBoZXJlLlxuICAgICAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9ICgwLCBfcmVhY3QudXNlKShsYXp5RGF0YSk7XG4gICAgICAgIGlmICghY2hpbGROb2RlLmxhenlEYXRhUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIC8vIHNldFRpbWVvdXQgaXMgdXNlZCB0byBzdGFydCBhIG5ldyB0cmFuc2l0aW9uIGR1cmluZyByZW5kZXIsIHRoaXMgaXMgYW4gaW50ZW50aW9uYWwgaGFjayBhcm91bmQgUmVhY3QuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgKDAsIF9yZWFjdC5zdGFydFRyYW5zaXRpb24pKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUJ5U2VydmVyUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUcmVlOiBmdWxsVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIG1hcmsgdGhpcyBhcyByZXNvbHZlZCwgaW4gY2FzZSB0aGlzIGJyYW5jaCBpcyByZXBsYXllZCwgd2UgZG9uJ3Qgd2FudCB0byBjb250aW5vdXNseSByZS1hcHBseVxuICAgICAgICAgICAgLy8gdGhlIHBhdGNoIHRvIHRoZSB0cmVlLlxuICAgICAgICAgICAgY2hpbGROb2RlLmxhenlEYXRhUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1c3BlbmQgaW5maW5pdGVseSBhcyBgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZWAgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBwYXJ0IG9mIHRoZSB0cmVlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAvLyBBIGZhbHNleSBgcmVzb2x2ZWRSc2NgIGluZGljYXRlcyBtaXNzaW5nIGRhdGEgLS0gd2Ugc2hvdWxkIG5vdCBjb21taXQgdGhhdCBicmFuY2gsIGFuZCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBkYXRhIHRvIGFycml2ZS5cbiAgICAgICAgKDAsIF9yZWFjdC51c2UpKF91bnJlc29sdmVkdGhlbmFibGUudW5yZXNvbHZlZFRoZW5hYmxlKTtcbiAgICB9XG4gICAgLy8gSWYgd2UgZ2V0IHRvIHRoaXMgcG9pbnQsIHRoZW4gd2Uga25vdyB3ZSBoYXZlIHNvbWV0aGluZyB3ZSBjYW4gcmVuZGVyLlxuICAgIGNvbnN0IHN1YnRyZWUgPSAvLyBUaGUgbGF5b3V0IHJvdXRlciBjb250ZXh0IG5hcnJvd3MgZG93biB0cmVlIGFuZCBjaGlsZE5vZGVzIGF0IGVhY2ggbGV2ZWwuXG4gICAgLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHJlZTogdHJlZVsxXVtwYXJhbGxlbFJvdXRlcktleV0sXG4gICAgICAgICAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGUucGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogb3ZlcnJpZGluZyBvZiB1cmwgZm9yIHBhcmFsbGVsIHJvdXRlc1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBsb2FkaW5nOiBjaGlsZE5vZGUubG9hZGluZ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogcmVzb2x2ZWRSc2NcbiAgICB9KTtcbiAgICAvLyBFbnN1cmUgcm9vdCBsYXlvdXQgaXMgbm90IHdyYXBwZWQgaW4gYSBkaXYgYXMgdGhlIHJvb3QgbGF5b3V0IHJlbmRlcnMgYDxodG1sPmBcbiAgICByZXR1cm4gc3VidHJlZTtcbn1cbi8qKlxuICogUmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSB3aXRoIHRoZSBwcm92aWRlZCBcImxvYWRpbmdcIiBwcm9wZXJ0eSBhcyB0aGUgZmFsbGJhY2suXG4gKiBJZiBubyBsb2FkaW5nIHByb3BlcnR5IGlzIHByb3ZpZGVkIGl0IHJlbmRlcnMgdGhlIGNoaWxkcmVuIHdpdGhvdXQgYSBzdXNwZW5zZSBib3VuZGFyeS5cbiAqLyBmdW5jdGlvbiBMb2FkaW5nQm91bmRhcnkocGFyYW0pIHtcbiAgICBsZXQgeyBjaGlsZHJlbiwgaGFzTG9hZGluZywgbG9hZGluZywgbG9hZGluZ1N0eWxlcywgbG9hZGluZ1NjcmlwdHMgfSA9IHBhcmFtO1xuICAgIC8vIFdlIGhhdmUgYW4gZXhwbGljaXQgcHJvcCBmb3IgY2hlY2tpbmcgaWYgYGxvYWRpbmdgIGlzIHByb3ZpZGVkLCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiBhIGxvYWRpbmdcbiAgICAvLyBjb21wb25lbnQgdGhhdCByZXR1cm5zIGBudWxsYCAvIGB1bmRlZmluZWRgLCB2cyBub3QgaGF2aW5nIGEgbG9hZGluZyBjb21wb25lbnQgYXQgYWxsLlxuICAgIGlmIChoYXNMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9yZWFjdC5TdXNwZW5zZSwge1xuICAgICAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeHMpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1N0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1NjcmlwdHMsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSk7XG59XG5mdW5jdGlvbiBPdXRlckxheW91dFJvdXRlcihwYXJhbSkge1xuICAgIGxldCB7IHBhcmFsbGVsUm91dGVyS2V5LCBzZWdtZW50UGF0aCwgZXJyb3IsIGVycm9yU3R5bGVzLCBlcnJvclNjcmlwdHMsIHRlbXBsYXRlU3R5bGVzLCB0ZW1wbGF0ZVNjcmlwdHMsIHRlbXBsYXRlLCBub3RGb3VuZCwgbm90Rm91bmRTdHlsZXMgfSA9IHBhcmFtO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5MYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YXJpYW50IGV4cGVjdGVkIGxheW91dCByb3V0ZXIgdG8gYmUgbW91bnRlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZE5vZGVzLCB0cmVlLCB1cmwsIGxvYWRpbmcgfSA9IGNvbnRleHQ7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHBhcmFsbGVsUm91dGVyIGNhY2hlIG5vZGVcbiAgICBsZXQgY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyID0gY2hpbGROb2Rlcy5nZXQocGFyYWxsZWxSb3V0ZXJLZXkpO1xuICAgIC8vIElmIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZSBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC5cbiAgICAvLyBUaGlzIHdyaXRlcyB0byB0aGUgY2FjaGUgd2hlbiB0aGVyZSBpcyBubyBpdGVtIGluIHRoZSBjYWNoZSB5ZXQuIEl0IG5ldmVyICpvdmVyd3JpdGVzKiBleGlzdGluZyBjYWNoZSBpdGVtcyB3aGljaCBpcyB3aHkgaXQncyBzYWZlIGluIGNvbmN1cnJlbnQgbW9kZS5cbiAgICBpZiAoIWNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcikge1xuICAgICAgICBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KHBhcmFsbGVsUm91dGVyS2V5LCBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIpO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGFjdGl2ZSBzZWdtZW50IGluIHRoZSB0cmVlXG4gICAgLy8gVGhlIHJlYXNvbiBhcnJheXMgYXJlIHVzZWQgaW4gdGhlIGRhdGEgZm9ybWF0IGlzIHRoYXQgdGhlc2UgYXJlIHRyYW5zZmVycmVkIGZyb20gdGhlIHNlcnZlciB0byB0aGUgYnJvd3NlciBzbyBpdCdzIG9wdGltaXplZCB0byBzYXZlIGJ5dGVzLlxuICAgIGNvbnN0IHRyZWVTZWdtZW50ID0gdHJlZVsxXVtwYXJhbGxlbFJvdXRlcktleV1bMF07XG4gICAgLy8gSWYgc2VnbWVudCBpcyBhbiBhcnJheSBpdCdzIGEgZHluYW1pYyByb3V0ZSBhbmQgd2Ugd2FudCB0byByZWFkIHRoZSBkeW5hbWljIHJvdXRlIHZhbHVlIGFzIHRoZSBzZWdtZW50IHRvIGdldCBmcm9tIHRoZSBjYWNoZS5cbiAgICBjb25zdCBjdXJyZW50Q2hpbGRTZWdtZW50VmFsdWUgPSAoMCwgX2dldHNlZ21lbnR2YWx1ZS5nZXRTZWdtZW50VmFsdWUpKHRyZWVTZWdtZW50KTtcbiAgICAvKipcbiAgICogRGVjaWRlcyB3aGljaCBzZWdtZW50cyB0byBrZWVwIHJlbmRlcmluZywgYWxsIHNlZ21lbnRzIHRoYXQgYXJlIG5vdCBhY3RpdmUgd2lsbCBiZSB3cmFwcGVkIGluIGA8T2Zmc2NyZWVuPmAuXG4gICAqLyAvLyBUT0RPLUFQUDogQWRkIGhhbmRsaW5nIG9mIGA8T2Zmc2NyZWVuPmAgd2hlbiBpdCdzIGF2YWlsYWJsZS5cbiAgICBjb25zdCBwcmVzZXJ2ZWRTZWdtZW50cyA9IFtcbiAgICAgICAgdHJlZVNlZ21lbnRcbiAgICBdO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBwcmVzZXJ2ZWRTZWdtZW50cy5tYXAoKHByZXNlcnZlZFNlZ21lbnQpPT57XG4gICAgICAgICAgICBjb25zdCBwcmVzZXJ2ZWRTZWdtZW50VmFsdWUgPSAoMCwgX2dldHNlZ21lbnR2YWx1ZS5nZXRTZWdtZW50VmFsdWUpKHByZXNlcnZlZFNlZ21lbnQpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShwcmVzZXJ2ZWRTZWdtZW50KTtcbiAgICAgICAgICAgIHJldHVybigvKlxuICAgICAgICAgICAgLSBFcnJvciBib3VuZGFyeVxuICAgICAgICAgICAgICAtIE9ubHkgcmVuZGVycyBlcnJvciBib3VuZGFyeSBpZiBlcnJvciBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBlcnJvciBzdGF0ZS5cbiAgICAgICAgICAgIC0gTG9hZGluZyBib3VuZGFyeVxuICAgICAgICAgICAgICAtIE9ubHkgcmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSBpZiBsb2FkaW5nIGNvbXBvbmVudHMgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBsb2FkaW5nIHN0YXRlLlxuICAgICAgICAgICAgICAtIFBhc3NlZCB0byB0aGUgcm91dGVyIGR1cmluZyByZW5kZXJpbmcgdG8gZW5zdXJlIGl0IGNhbiBiZSBpbW1lZGlhdGVseSByZW5kZXJlZCB3aGVuIHN1c3BlbmRpbmcgb24gYSBGbGlnaHQgZmV0Y2guXG4gICAgICAgICAgKi8gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4cykoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLlRlbXBsYXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFNjcm9sbEFuZEZvY3VzSGFuZGxlciwge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9lcnJvcmJvdW5kYXJ5LkVycm9yQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50OiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3R5bGVzOiBlcnJvclN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU2NyaXB0czogZXJyb3JTY3JpcHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoTG9hZGluZ0JvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzTG9hZGluZzogQm9vbGVhbihsb2FkaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBsb2FkaW5nID09IG51bGwgPyB2b2lkIDAgOiBsb2FkaW5nWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmdTdHlsZXM6IGxvYWRpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IGxvYWRpbmdbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1NjcmlwdHM6IGxvYWRpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IGxvYWRpbmdbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX25vdGZvdW5kYm91bmRhcnkuTm90Rm91bmRCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kU3R5bGVzOiBub3RGb3VuZFN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX3JlZGlyZWN0Ym91bmRhcnkuUmVkaXJlY3RCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoSW5uZXJMYXlvdXRSb3V0ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlcktleTogcGFyYWxsZWxSb3V0ZXJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogdHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudFBhdGg6IHNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZTogY3VycmVudENoaWxkU2VnbWVudFZhbHVlID09PSBwcmVzZXJ2ZWRTZWdtZW50VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVTdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlU2NyaXB0cyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShwcmVzZXJ2ZWRTZWdtZW50LCB0cnVlKSkpO1xuICAgICAgICB9KVxuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJfdG9Db25zdW1hYmxlQXJyYXkiLCJyZXF1aXJlIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NyZWF0ZUNsYXNzIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIl9pbmhlcml0cyIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2dldFByb3RvdHlwZU9mIiwiX2RlZmluZVByb3BlcnR5IiwiX3NsaWNlZFRvQXJyYXkiLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwicmVzdWx0IiwiTmV3VGFyZ2V0IiwiY29uc3RydWN0b3IiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXJndW1lbnRzIiwiYXBwbHkiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwicHJvdG90eXBlIiwidmFsdWVPZiIsImNhbGwiLCJlIiwib3duS2V5cyIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJsZW5ndGgiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldCIsIk91dGVyTGF5b3V0Um91dGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9qc3hydW50aW1lIiwiX3JlYWN0IiwiXyIsIl9yZWFjdGRvbSIsIl9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwiX3VucmVzb2x2ZWR0aGVuYWJsZSIsIl9lcnJvcmJvdW5kYXJ5IiwiX21hdGNoc2VnbWVudHMiLCJfaGFuZGxlc21vb3Roc2Nyb2xsIiwiX3JlZGlyZWN0Ym91bmRhcnkiLCJfbm90Zm91bmRib3VuZGFyeSIsIl9nZXRzZWdtZW50dmFsdWUiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlIiwid2Fsa0FkZFJlZmV0Y2giLCJzZWdtZW50UGF0aFRvV2FsayIsInRyZWVUb1JlY3JlYXRlIiwiX3NlZ21lbnRQYXRoVG9XYWxrIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJpc0xhc3QiLCJtYXRjaFNlZ21lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsInN1YlRyZWUiLCJ1bmRlZmluZWQiLCJzbGljZSIsImZpbmRET01Ob2RlIiwiaW5zdGFuY2UiLCJvcmlnaW5hbENvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsIl9sZW4iLCJtZXNzYWdlcyIsIkFycmF5IiwiX2tleSIsImluY2x1ZGVzIiwicmVjdFByb3BlcnRpZXMiLCJzaG91bGRTa2lwRWxlbWVudCIsImVsZW1lbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJ3YXJuIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImV2ZXJ5IiwiaXRlbSIsInRvcE9mRWxlbWVudEluVmlld3BvcnQiLCJ2aWV3cG9ydEhlaWdodCIsInRvcCIsImdldEhhc2hGcmFnbWVudERvbU5vZGUiLCJoYXNoRnJhZ21lbnQiLCJkb2N1bWVudCIsImJvZHkiLCJfZG9jdW1lbnRfZ2V0RWxlbWVudEJ5SWQiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiSW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJfcmVhY3QkZGVmYXVsdCRDb21wb24iLCJfc3VwZXIiLCJfdGhpcyIsIl9sZW4yIiwiYXJncyIsIl9rZXkyIiwiY29uY2F0IiwiaGFuZGxlUG90ZW50aWFsU2Nyb2xsIiwiX3RoaXMkcHJvcHMiLCJwcm9wcyIsImZvY3VzQW5kU2Nyb2xsUmVmIiwic2VnbWVudFBhdGgiLCJzZWdtZW50UGF0aHMiLCJzb21lIiwic2Nyb2xsUmVmU2VnbWVudFBhdGgiLCJpbmRleCIsImRvbU5vZGUiLCJFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJzY3JvbGxJbnRvVmlldyIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsVG9wIiwiZG9udEZvcmNlTGF5b3V0Iiwib25seUhhc2hDaGFuZ2UiLCJmb2N1cyIsImtleSIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwicmVuZGVyIiwiY2hpbGRyZW4iLCJDb21wb25lbnQiLCJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJwYXJhbSIsImNvbnRleHQiLCJ1c2VDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkVycm9yIiwianN4IiwiX2MiLCJJbm5lckxheW91dFJvdXRlciIsInBhcmFsbGVsUm91dGVyS2V5IiwidXJsIiwiY2hpbGROb2RlcyIsInRyZWUiLCJjYWNoZUtleSIsImJ1aWxkSWQiLCJjaGFuZ2VCeVNlcnZlclJlc3BvbnNlIiwiZnVsbFRyZWUiLCJjaGlsZE5vZGUiLCJuZXdMYXp5Q2FjaGVOb2RlIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJwYXJhbGxlbFJvdXRlcyIsIk1hcCIsImxhenlEYXRhUmVzb2x2ZWQiLCJsb2FkaW5nIiwic2V0IiwicmVzb2x2ZWRQcmVmZXRjaFJzYyIsInVzZURlZmVycmVkVmFsdWUiLCJyZXNvbHZlZFJzYyIsInRoZW4iLCJ1c2UiLCJyZWZldGNoVHJlZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwibmV4dFVybCIsInNlcnZlclJlc3BvbnNlIiwic2V0VGltZW91dCIsInN0YXJ0VHJhbnNpdGlvbiIsInByZXZpb3VzVHJlZSIsInVucmVzb2x2ZWRUaGVuYWJsZSIsInN1YnRyZWUiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJfYzIiLCJMb2FkaW5nQm91bmRhcnkiLCJoYXNMb2FkaW5nIiwibG9hZGluZ1N0eWxlcyIsImxvYWRpbmdTY3JpcHRzIiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsImpzeHMiLCJGcmFnbWVudCIsIl9jMyIsImVycm9yU3R5bGVzIiwiZXJyb3JTY3JpcHRzIiwidGVtcGxhdGVTdHlsZXMiLCJ0ZW1wbGF0ZVNjcmlwdHMiLCJ0ZW1wbGF0ZSIsIm5vdEZvdW5kIiwibm90Rm91bmRTdHlsZXMiLCJjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIiLCJ0cmVlU2VnbWVudCIsImN1cnJlbnRDaGlsZFNlZ21lbnRWYWx1ZSIsImdldFNlZ21lbnRWYWx1ZSIsInByZXNlcnZlZFNlZ21lbnRzIiwibWFwIiwicHJlc2VydmVkU2VnbWVudCIsInByZXNlcnZlZFNlZ21lbnRWYWx1ZSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiVGVtcGxhdGVDb250ZXh0IiwiRXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiTm90Rm91bmRCb3VuZGFyeSIsIlJlZGlyZWN0Qm91bmRhcnkiLCJpc0FjdGl2ZSIsIl9jNCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiLCIkUmVmcmVzaFJlZyQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return RenderFromTemplateContext;\n    }\n}));\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nfunction RenderFromTemplateContext() {\n    var children = (0, _react.useContext)(_approutercontextsharedruntime.TemplateContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c1 = RenderFromTemplateContext;\n_c = RenderFromTemplateContext;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n}\nvar _c;\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\nvar _c1;\n$RefreshReg$(_c1, \"RenderFromTemplateContext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLLFNBQUFBO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLElBQU1DLDRCQUE0QkMsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLElBQU1DLGNBQWNELG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxJQUFNRSxTQUFTLGNBQWNILDBCQUEwQkksQ0FBQyxDQUFDSCxtQkFBT0EsQ0FBQyxtRkFBTztBQUN4RSxJQUFNSSxpQ0FBaUNKLG1CQUFPQSxDQUFDLHdKQUFvRDtBQUNuRyxTQUFTRjtJQUNMLElBQU1PLFdBQVcsQ0FBQyxHQUFHSCxPQUFPSSxVQUFVLEVBQUVGLCtCQUErQkcsZUFBZTtJQUN0RixPQUFxQixXQUFkLEdBQWUsSUFBR04sWUFBWU8sR0FBRyxFQUFFUCxZQUFZUSxRQUFRLEVBQUU7UUFDNURKLFVBQVVBO0lBQ2Q7QUFDSjtNQUxTUDtBQUtSWSxLQUxRWjtBQU9ULElBQUksQ0FBQyxPQUFPSixPQUFPLFdBQVEsS0FBSyxjQUFlLE9BQU9BLE9BQU8sV0FBUSxLQUFLLFlBQVlBLE9BQU8sV0FBUSxLQUFLLFNBQVUsT0FBT0EsT0FBTyxXQUFRLENBQUNpQixVQUFVLEtBQUssYUFBYTtJQUNyS25CLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBTyxXQUFRLEVBQUUsY0FBYztRQUFFQyxPQUFPO0lBQUs7SUFDbkVILE9BQU9vQixNQUFNLENBQUNsQixPQUFPLFdBQVEsRUFBRUE7SUFDL0JtQixPQUFPbkIsT0FBTyxHQUFHQSxPQUFPLFdBQVE7QUFDbEM7QUFBQyxJQUFBZ0I7QUFBQUksYUFBQUosSUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanM/OGVlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuZnVuY3Rpb24gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLlRlbXBsYXRlQ29udGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9qc3hydW50aW1lIiwiX3JlYWN0IiwiXyIsIl9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsImNoaWxkcmVuIiwidXNlQ29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCIsImpzeCIsIkZyYWdtZW50IiwiX2MiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIiwiJFJlZnJlc2hSZWckIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/search-params.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/search-params.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createDynamicallyTrackedSearchParams: function createDynamicallyTrackedSearchParams() {\n        return _createDynamicallyTrackedSearchParams;\n    },\n    createUntrackedSearchParams: function createUntrackedSearchParams() {\n        return _createUntrackedSearchParams;\n    }\n});\nvar _staticgenerationasyncstorageexternal = __webpack_require__(/*! ./static-generation-async-storage.external */ \"(shared)/./node_modules/next/dist/client/components/static-generation-async-storage.external.js\");\nvar _dynamicrendering = __webpack_require__(/*! ../../server/app-render/dynamic-rendering */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nvar _reflect = __webpack_require__(/*! ../../server/web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nfunction _createUntrackedSearchParams(searchParams) {\n    var store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (store && store.forceStatic) {\n        return {};\n    } else {\n        return searchParams;\n    }\n}\nfunction _createDynamicallyTrackedSearchParams(searchParams) {\n    var store = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (!store) {\n        // we assume we are in a route handler or page render. just return the searchParams\n        return searchParams;\n    } else if (store.forceStatic) {\n        // If we forced static we omit searchParams entirely. This is true both during SSR\n        // and browser render because we need there to be parity between these environments\n        return {};\n    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {\n        // during dynamic renders we don't actually have to track anything so we just return\n        // the searchParams directly. However if dynamic data access should error then we\n        // still want to track access. This covers the case in Dev where all renders are dynamic\n        // but we still want to error if you use a dynamic data source because it will fail the build\n        // or revalidate if you do.\n        return searchParams;\n    } else {\n        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because\n        // these can all be used to exfiltrate information about searchParams.\n        return new Proxy({}, {\n            get: function get(target, prop, receiver) {\n                if (typeof prop === \"string\") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, \"searchParams.\" + prop);\n                }\n                return _reflect.ReflectAdapter.get(target, prop, receiver);\n            },\n            has: function has(target, prop) {\n                if (typeof prop === \"string\") {\n                    (0, _dynamicrendering.trackDynamicDataAccessed)(store, \"searchParams.\" + prop);\n                }\n                return Reflect.has(target, prop);\n            },\n            ownKeys: function ownKeys(target) {\n                (0, _dynamicrendering.trackDynamicDataAccessed)(store, \"searchParams\");\n                return Reflect.ownKeys(target);\n            }\n        });\n    }\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc2VhcmNoLXBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSTtJQUNqQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsc0NBQXNDLFNBQUFBO1FBQ2xDLE9BQU9BO0lBQ1g7SUFDQUMsNkJBQTZCLFNBQUFBO1FBQ3pCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLElBQU1PLHdDQUF3Q0MsbUJBQU9BLENBQUMsbUpBQTRDO0FBQ2xHLElBQU1DLG9CQUFvQkQsbUJBQU9BLENBQUMsc0lBQTJDO0FBQzdFLElBQU1FLFdBQVdGLG1CQUFPQSxDQUFDLG9KQUFrRDtBQUMzRSxTQUFTUiw2QkFBNEJXLFlBQVk7SUFDN0MsSUFBTUMsUUFBUUwsc0NBQXNDTSw0QkFBNEIsQ0FBQ0MsUUFBUTtJQUN6RixJQUFJRixTQUFTQSxNQUFNRyxXQUFXLEVBQUU7UUFDNUIsT0FBTyxDQUFDO0lBQ1osT0FBTztRQUNILE9BQU9KO0lBQ1g7QUFDSjtBQUNBLFNBQVNaLHNDQUFxQ1ksWUFBWTtJQUN0RCxJQUFNQyxRQUFRTCxzQ0FBc0NNLDRCQUE0QixDQUFDQyxRQUFRO0lBQ3pGLElBQUksQ0FBQ0YsT0FBTztRQUNSO1FBQ0EsT0FBT0Q7SUFDWCxPQUFPLElBQUlDLE1BQU1HLFdBQVcsRUFBRTtRQUMxQjtRQUNBO1FBQ0EsT0FBTyxDQUFDO0lBQ1osT0FBTyxJQUFJLENBQUNILE1BQU1JLGtCQUFrQixJQUFJLENBQUNKLE1BQU1LLGtCQUFrQixFQUFFO1FBQy9EO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxPQUFPTjtJQUNYLE9BQU87UUFDSDtRQUNBO1FBQ0EsT0FBTyxJQUFJTyxNQUFNLENBQUMsR0FBRztZQUNqQlosS0FBRyxTQUFBQSxJQUFFSixNQUFNLEVBQUVpQixJQUFJLEVBQUVDLFFBQVE7Z0JBQ3ZCLElBQUksT0FBT0QsU0FBUyxVQUFVO29CQUN6QixJQUFHVixrQkFBa0JZLHdCQUF3QixFQUFFVCxPQUFPLGtCQUFrQk87Z0JBQzdFO2dCQUNBLE9BQU9ULFNBQVNZLGNBQWMsQ0FBQ2hCLEdBQUcsQ0FBQ0osUUFBUWlCLE1BQU1DO1lBQ3JEO1lBQ0FHLEtBQUcsU0FBQUEsSUFBRXJCLE1BQU0sRUFBRWlCLElBQUk7Z0JBQ2IsSUFBSSxPQUFPQSxTQUFTLFVBQVU7b0JBQ3pCLElBQUdWLGtCQUFrQlksd0JBQXdCLEVBQUVULE9BQU8sa0JBQWtCTztnQkFDN0U7Z0JBQ0EsT0FBT0ssUUFBUUQsR0FBRyxDQUFDckIsUUFBUWlCO1lBQy9CO1lBQ0FNLFNBQU8sU0FBQUEsUUFBRXZCLE1BQU07Z0JBQ1YsSUFBR08sa0JBQWtCWSx3QkFBd0IsRUFBRVQsT0FBTztnQkFDdkQsT0FBT1ksUUFBUUMsT0FBTyxDQUFDdkI7WUFDM0I7UUFDSjtJQUNKO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT04sT0FBTyxXQUFRLEtBQUssY0FBZSxPQUFPQSxPQUFPLFdBQVEsS0FBSyxZQUFZQSxPQUFPLFdBQVEsS0FBSyxTQUFVLE9BQU9BLE9BQU8sV0FBUSxDQUFDOEIsVUFBVSxLQUFLLGFBQWE7SUFDcktoQyxPQUFPQyxjQUFjLENBQUNDLE9BQU8sV0FBUSxFQUFFLGNBQWM7UUFBRUMsT0FBTztJQUFLO0lBQ25FSCxPQUFPaUMsTUFBTSxDQUFDL0IsT0FBTyxXQUFRLEVBQUVBO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLE9BQU8sV0FBUTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3NlYXJjaC1wYXJhbXMuanM/MzYzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNyZWF0ZUR5bmFtaWNhbGx5VHJhY2tlZFNlYXJjaFBhcmFtczogbnVsbCxcbiAgICBjcmVhdGVVbnRyYWNrZWRTZWFyY2hQYXJhbXM6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgY3JlYXRlRHluYW1pY2FsbHlUcmFja2VkU2VhcmNoUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNhbGx5VHJhY2tlZFNlYXJjaFBhcmFtcztcbiAgICB9LFxuICAgIGNyZWF0ZVVudHJhY2tlZFNlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVVbnRyYWNrZWRTZWFyY2hQYXJhbXM7XG4gICAgfVxufSk7XG5jb25zdCBfc3RhdGljZ2VuZXJhdGlvbmFzeW5jc3RvcmFnZWV4dGVybmFsID0gcmVxdWlyZShcIi4vc3RhdGljLWdlbmVyYXRpb24tYXN5bmMtc3RvcmFnZS5leHRlcm5hbFwiKTtcbmNvbnN0IF9keW5hbWljcmVuZGVyaW5nID0gcmVxdWlyZShcIi4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nXCIpO1xuY29uc3QgX3JlZmxlY3QgPSByZXF1aXJlKFwiLi4vLi4vc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0XCIpO1xuZnVuY3Rpb24gY3JlYXRlVW50cmFja2VkU2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcykge1xuICAgIGNvbnN0IHN0b3JlID0gX3N0YXRpY2dlbmVyYXRpb25hc3luY3N0b3JhZ2VleHRlcm5hbC5zdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHN0b3JlICYmIHN0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VhcmNoUGFyYW1zO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNhbGx5VHJhY2tlZFNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpIHtcbiAgICBjb25zdCBzdG9yZSA9IF9zdGF0aWNnZW5lcmF0aW9uYXN5bmNzdG9yYWdlZXh0ZXJuYWwuc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmICghc3RvcmUpIHtcbiAgICAgICAgLy8gd2UgYXNzdW1lIHdlIGFyZSBpbiBhIHJvdXRlIGhhbmRsZXIgb3IgcGFnZSByZW5kZXIuIGp1c3QgcmV0dXJuIHRoZSBzZWFyY2hQYXJhbXNcbiAgICAgICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbiAgICB9IGVsc2UgaWYgKHN0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAgIC8vIElmIHdlIGZvcmNlZCBzdGF0aWMgd2Ugb21pdCBzZWFyY2hQYXJhbXMgZW50aXJlbHkuIFRoaXMgaXMgdHJ1ZSBib3RoIGR1cmluZyBTU1JcbiAgICAgICAgLy8gYW5kIGJyb3dzZXIgcmVuZGVyIGJlY2F1c2Ugd2UgbmVlZCB0aGVyZSB0byBiZSBwYXJpdHkgYmV0d2VlbiB0aGVzZSBlbnZpcm9ubWVudHNcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0gZWxzZSBpZiAoIXN0b3JlLmlzU3RhdGljR2VuZXJhdGlvbiAmJiAhc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgIC8vIGR1cmluZyBkeW5hbWljIHJlbmRlcnMgd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSB0byB0cmFjayBhbnl0aGluZyBzbyB3ZSBqdXN0IHJldHVyblxuICAgICAgICAvLyB0aGUgc2VhcmNoUGFyYW1zIGRpcmVjdGx5LiBIb3dldmVyIGlmIGR5bmFtaWMgZGF0YSBhY2Nlc3Mgc2hvdWxkIGVycm9yIHRoZW4gd2VcbiAgICAgICAgLy8gc3RpbGwgd2FudCB0byB0cmFjayBhY2Nlc3MuIFRoaXMgY292ZXJzIHRoZSBjYXNlIGluIERldiB3aGVyZSBhbGwgcmVuZGVycyBhcmUgZHluYW1pY1xuICAgICAgICAvLyBidXQgd2Ugc3RpbGwgd2FudCB0byBlcnJvciBpZiB5b3UgdXNlIGEgZHluYW1pYyBkYXRhIHNvdXJjZSBiZWNhdXNlIGl0IHdpbGwgZmFpbCB0aGUgYnVpbGRcbiAgICAgICAgLy8gb3IgcmV2YWxpZGF0ZSBpZiB5b3UgZG8uXG4gICAgICAgIHJldHVybiBzZWFyY2hQYXJhbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFjayBkeW5hbWljIGFjY2VzcyB3aXRoIGEgUHJveHkuIFdlIGltcGxlbWVudCBnZXQsIGhhcywgYW5kIG93bktleXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGVzZSBjYW4gYWxsIGJlIHVzZWQgdG8gZXhmaWx0cmF0ZSBpbmZvcm1hdGlvbiBhYm91dCBzZWFyY2hQYXJhbXMuXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudHJhY2tEeW5hbWljRGF0YUFjY2Vzc2VkKShzdG9yZSwgXCJzZWFyY2hQYXJhbXMuXCIgKyBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXMgKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudHJhY2tEeW5hbWljRGF0YUFjY2Vzc2VkKShzdG9yZSwgXCJzZWFyY2hQYXJhbXMuXCIgKyBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3duS2V5cyAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZCkoc3RvcmUsIFwic2VhcmNoUGFyYW1zXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWFyY2gtcGFyYW1zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImNyZWF0ZUR5bmFtaWNhbGx5VHJhY2tlZFNlYXJjaFBhcmFtcyIsImNyZWF0ZVVudHJhY2tlZFNlYXJjaFBhcmFtcyIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9zdGF0aWNnZW5lcmF0aW9uYXN5bmNzdG9yYWdlZXh0ZXJuYWwiLCJyZXF1aXJlIiwiX2R5bmFtaWNyZW5kZXJpbmciLCJfcmVmbGVjdCIsInNlYXJjaFBhcmFtcyIsInN0b3JlIiwic3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSIsImdldFN0b3JlIiwiZm9yY2VTdGF0aWMiLCJpc1N0YXRpY0dlbmVyYXRpb24iLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJQcm94eSIsInByb3AiLCJyZWNlaXZlciIsInRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZCIsIlJlZmxlY3RBZGFwdGVyIiwiaGFzIiwiUmVmbGVjdCIsIm93bktleXMiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/search-params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/static-generation-bailout.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-bailout.js ***!
  \*******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\nvar _inherits = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js\");\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js\");\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js\");\nvar _wrapNativeSuper = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/wrapNativeSuper.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/@babel/runtime/helpers/wrapNativeSuper.js\");\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function StaticGenBailoutError() {\n        return _StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function isStaticGenBailoutError() {\n        return _isStaticGenBailoutError;\n    }\n});\nvar NEXT_STATIC_GEN_BAILOUT = \"NEXT_STATIC_GEN_BAILOUT\";\nvar _StaticGenBailoutError = /*#__PURE__*/ function(_Error) {\n    _inherits(_StaticGenBailoutError, _Error);\n    var _super = _createSuper(_StaticGenBailoutError);\n    function _StaticGenBailoutError() {\n        var _this;\n        _classCallCheck(this, _StaticGenBailoutError);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [\n            this\n        ].concat(args));\n        _this.code = NEXT_STATIC_GEN_BAILOUT;\n        return _this;\n    }\n    return _createClass(_StaticGenBailoutError);\n}(/*#__PURE__*/ _wrapNativeSuper(Error));\nfunction _isStaticGenBailoutError(error) {\n    if (typeof error !== \"object\" || error === null || !(\"code\" in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUFBLElBQUFBLGVBQUFDLG1CQUFBQSxDQUFBO0FBQUEsSUFBQUMsa0JBQUFELG1CQUFBQSxDQUFBO0FBQUEsSUFBQUUsWUFBQUYsbUJBQUFBLENBQUE7QUFBQSxJQUFBRyw2QkFBQUgsbUJBQUFBLENBQUE7QUFBQSxJQUFBSSxrQkFBQUosbUJBQUFBLENBQUE7QUFBQSxJQUFBSyxtQkFBQUwsbUJBQUFBLENBQUE7QUFBQSxTQUFBTSxhQUFBQyxPQUFBO0lBQUEsSUFBQUMsNEJBQUFDO0lBQUEsZ0JBQUFDO1FBQUEsSUFBQUMsUUFBQVAsZ0JBQUFHLFVBQUFLO1FBQUEsSUFBQUosMkJBQUE7WUFBQSxJQUFBSyxZQUFBVCxnQkFBQSxNQUFBVSxXQUFBO1lBQUFGLFNBQUFHLFFBQUFDLFNBQUEsQ0FBQUwsT0FBQU0sV0FBQUo7UUFBQTtZQUFBRCxTQUFBRCxNQUFBTyxLQUFBLE9BQUFEO1FBQUE7UUFBQSxPQUFBZCwyQkFBQSxNQUFBUztJQUFBO0FBQUE7QUFBQSxTQUFBSDtJQUFBLFdBQUFNLFlBQUEsZ0JBQUFBLFFBQUFDLFNBQUE7SUFBQSxJQUFBRCxRQUFBQyxTQUFBLENBQUFHLElBQUE7SUFBQSxXQUFBQyxVQUFBO0lBQUE7UUFBQUMsUUFBQUMsU0FBQSxDQUFBQyxPQUFBLENBQUFDLElBQUEsQ0FBQVQsUUFBQUMsU0FBQSxDQUFBSyxTQUFBO1FBQUE7SUFBQSxTQUFBSSxHQUFBO1FBQUE7SUFBQTtBQUFBO0FBQ2JDLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBR047QUFDQSxTQUFTRyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVCxPQUFPQyxjQUFjLENBQUNPLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFJO0lBQ2pCO0FBQ0o7QUFDQUgsUUFBUUwsU0FBUztJQUNiRyx1QkFBdUIsU0FBQUE7UUFDbkIsT0FBT0E7SUFDWDtJQUNBQyx5QkFBeUIsU0FBQUE7UUFDckIsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsSUFBTU8sMEJBQTBCO0FBQTBCLElBQ3BEUix5QkFBcUIsdUJBQUFTLE1BQUE7SUFBQXRDLFVBQUF1Qyx3QkFBQUQ7SUFBQSxJQUFBRSxTQUFBcEMsYUFBQW1DO0lBQ3ZCLFNBQUFBO1FBQW9CLElBQUFFO1FBQUExQyxnQkFBQSxNQUFBd0M7UUFBQSxRQUFBRyxPQUFBM0IsVUFBQTRCLE1BQUEsRUFBTEMsT0FBSSxJQUFBQyxNQUFBSCxPQUFBSSxPQUFBLEdBQUFBLE9BQUFKLE1BQUFJLE9BQUE7WUFBSkYsSUFBSSxDQUFBRSxLQUFBLEdBQUEvQixTQUFBLENBQUErQixLQUFBO1FBQUE7UUFDZkwsUUFBQUQsT0FBQWxCLElBQUEsQ0FBQU4sS0FBQSxDQUFBd0IsUUFBQTtZQUFBO1NBQUEsQ0FBQU8sTUFBQSxDQUFTSDtRQUNUSCxNQUFLTyxJQUFJLEdBQUdYO1FBQXdCLE9BQUFJO0lBQ3hDO0lBQUMsT0FBQTVDLGFBQUEwQztBQUFBLGdCQUFBcEMsaUJBSitCOEM7QUFNcEMsU0FBU25CLHlCQUF3Qm9CLEtBQUs7SUFDbEMsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxDQUFFLFdBQVVBLEtBQUFBLEdBQVE7UUFDbkUsT0FBTztJQUNYO0lBQ0EsT0FBT0EsTUFBTUYsSUFBSSxLQUFLWDtBQUMxQjtBQUVBLElBQUksQ0FBQyxPQUFPWCxPQUFPLFdBQVEsS0FBSyxjQUFlLE9BQU9BLE9BQU8sV0FBUSxLQUFLLFlBQVlBLE9BQU8sV0FBUSxLQUFLLFNBQVUsT0FBT0EsT0FBTyxXQUFRLENBQUN5QixVQUFVLEtBQUssYUFBYTtJQUNySzNCLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBTyxXQUFRLEVBQUUsY0FBYztRQUFFQyxPQUFPO0lBQUs7SUFDbkVILE9BQU80QixNQUFNLENBQUMxQixPQUFPLFdBQVEsRUFBRUE7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsT0FBTyxXQUFRO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dC5qcz8wNDZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgU3RhdGljR2VuQmFpbG91dEVycm9yOiBudWxsLFxuICAgIGlzU3RhdGljR2VuQmFpbG91dEVycm9yOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIFN0YXRpY0dlbkJhaWxvdXRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTdGF0aWNHZW5CYWlsb3V0RXJyb3I7XG4gICAgfSxcbiAgICBpc1N0YXRpY0dlbkJhaWxvdXRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc1N0YXRpY0dlbkJhaWxvdXRFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IE5FWFRfU1RBVElDX0dFTl9CQUlMT1VUID0gXCJORVhUX1NUQVRJQ19HRU5fQkFJTE9VVFwiO1xuY2xhc3MgU3RhdGljR2VuQmFpbG91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5jb2RlID0gTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3IoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yICE9PSBcIm9iamVjdFwiIHx8IGVycm9yID09PSBudWxsIHx8ICEoXCJjb2RlXCIgaW4gZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yLmNvZGUgPT09IE5FWFRfU1RBVElDX0dFTl9CQUlMT1VUO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LmpzLm1hcCJdLCJuYW1lcyI6WyJfY3JlYXRlQ2xhc3MiLCJyZXF1aXJlIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2luaGVyaXRzIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfZ2V0UHJvdG90eXBlT2YiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsInJlc3VsdCIsIk5ld1RhcmdldCIsImNvbnN0cnVjdG9yIiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFyZ3VtZW50cyIsImFwcGx5Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInByb3RvdHlwZSIsInZhbHVlT2YiLCJjYWxsIiwiZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiU3RhdGljR2VuQmFpbG91dEVycm9yIiwiaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJORVhUX1NUQVRJQ19HRU5fQkFJTE9VVCIsIl9FcnJvciIsIl9TdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJfc3VwZXIiLCJfdGhpcyIsIl9sZW4iLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiY29kZSIsIkVycm9yIiwiZXJyb3IiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/static-generation-bailout.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js ***!
  \********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleSmoothScroll\", ({\n    enumerable: true,\n    get: function get() {\n        return handleSmoothScroll;\n    }\n}));\nfunction handleSmoothScroll(fn, options) {\n    if (options === void 0) options = {};\n    // if only the hash is changed, we don't need to disable smooth scrolling\n    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n    if (options.onlyHashChange) {\n        fn();\n        return;\n    }\n    var htmlElement = document.documentElement;\n    var existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = \"auto\";\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGwuanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdBLEdBQWlCO0FBQ2pCQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUssU0FBQUE7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsbUJBQW1CQyxFQUFFLEVBQUVDLE9BQU87SUFDbkMsSUFBSUEsWUFBWSxLQUFLLEdBQUdBLFVBQVUsQ0FBQztJQUNuQztJQUNBO0lBQ0EsSUFBSUEsUUFBUUMsY0FBYyxFQUFFO1FBQ3hCRjtRQUNBO0lBQ0o7SUFDQSxJQUFNRyxjQUFjQyxTQUFTQyxlQUFlO0lBQzVDLElBQU1DLFdBQVdILFlBQVlJLEtBQUssQ0FBQ0MsY0FBYztJQUNqREwsWUFBWUksS0FBSyxDQUFDQyxjQUFjLEdBQUc7SUFDbkMsSUFBSSxDQUFDUCxRQUFRUSxlQUFlLEVBQUU7UUFDMUI7UUFDQTtRQUNBO1FBQ0FOLFlBQVlPLGNBQWM7SUFDOUI7SUFDQVY7SUFDQUcsWUFBWUksS0FBSyxDQUFDQyxjQUFjLEdBQUdGO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGwuanM/NjU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJ1biBmdW5jdGlvbiB3aXRoIGBzY3JvbGwtYmVoYXZpb3I6IGF1dG9gIGFwcGxpZWQgdG8gYDxodG1sLz5gLlxuICogVGhpcyBjc3MgY2hhbmdlIHdpbGwgYmUgcmV2ZXJ0ZWQgYWZ0ZXIgdGhlIGZ1bmN0aW9uIGZpbmlzaGVzLlxuICovIFwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFuZGxlU21vb3RoU2Nyb2xsXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTbW9vdGhTY3JvbGw7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBoYW5kbGVTbW9vdGhTY3JvbGwoZm4sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgLy8gaWYgb25seSB0aGUgaGFzaCBpcyBjaGFuZ2VkLCB3ZSBkb24ndCBuZWVkIHRvIGRpc2FibGUgc21vb3RoIHNjcm9sbGluZ1xuICAgIC8vIHdlIG9ubHkgY2FyZSB0byBwcmV2ZW50IHNtb290aCBzY3JvbGxpbmcgd2hlbiBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2UgdG8gYXZvaWQgamFycmluZyBVWFxuICAgIGlmIChvcHRpb25zLm9ubHlIYXNoQ2hhbmdlKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvcjtcbiAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwiYXV0b1wiO1xuICAgIGlmICghb3B0aW9ucy5kb250Rm9yY2VMYXlvdXQpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLWJhc2VkIGJyb3dzZXJzIHdlIG5lZWQgdG8gZm9yY2UgcmVmbG93IGJlZm9yZSBjYWxsaW5nIGBzY3JvbGxUb2AuXG4gICAgICAgIC8vIE90aGVyd2lzZSBpdCB3aWxsIG5vdCBwaWNrdXAgdGhlIGNoYW5nZSBpbiBzY3JvbGxCZWhhdmlvclxuICAgICAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy80MDcxOSNpc3N1ZWNvbW1lbnQtMTMzNjI0ODA0MlxuICAgICAgICBodG1sRWxlbWVudC5nZXRDbGllbnRSZWN0cygpO1xuICAgIH1cbiAgICBmbigpO1xuICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gZXhpc3Rpbmc7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhbmRsZS1zbW9vdGgtc2Nyb2xsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJmbiIsIm9wdGlvbnMiLCJvbmx5SGFzaENoYW5nZSIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJleGlzdGluZyIsInN0eWxlIiwic2Nyb2xsQmVoYXZpb3IiLCJkb250Rm9yY2VMYXlvdXQiLCJnZXRDbGllbnRSZWN0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Capp-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cnot-found-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CKIIT%5C%5CDesktop%5C%5Cwebdev%5C%5Ckiiiim%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);